-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus#readme</a>
@package plutus-playground-lib
@version 0.1.0.0

module Playground.API
type API = "contract" :> ReqBody '[JSON] SourceCode :> Post '[JSON] (Either [CompilationError] [FunctionSchema SimpleArgumentSchema]) :<|> "evaluate" :> ReqBody '[JSON] Evaluation :> Post '[JSON] EvaluationResult
newtype SourceCode
SourceCode :: Text -> SourceCode
newtype Fn
Fn :: Text -> Fn
data Expression
Action :: Fn -> Wallet -> [Value] -> Expression
[function] :: Expression -> Fn
[wallet] :: Expression -> Wallet
[arguments] :: Expression -> [Value]
Wait :: Int -> Expression
[blocks] :: Expression -> Int
type Program = [Expression]
data Evaluation
Evaluation :: [(Wallet, Integer)] -> Program -> SourceCode -> Blockchain -> Evaluation
[wallets] :: Evaluation -> [(Wallet, Integer)]
[program] :: Evaluation -> Program
[sourceCode] :: Evaluation -> SourceCode
[blockchain] :: Evaluation -> Blockchain
pubKeys :: Evaluation -> [PubKey]
data EvaluationResult
EvaluationResult :: Blockchain -> FlowGraph -> [EmulatorEvent] -> [(Wallet, Value)] -> EvaluationResult
[resultBlockchain] :: EvaluationResult -> Blockchain
[resultGraph] :: EvaluationResult -> FlowGraph
[emulatorLog] :: EvaluationResult -> [EmulatorEvent]
[fundsDistribution] :: EvaluationResult -> [(Wallet, Value)]
data FunctionSchema a
FunctionSchema :: Fn -> [a] -> FunctionSchema a
[functionName] :: FunctionSchema a -> Fn
[argumentSchema] :: FunctionSchema a -> [a]
data SimpleArgumentSchema
SimpleIntArgument :: SimpleArgumentSchema
SimpleStringArgument :: SimpleArgumentSchema
SimpleObjectArgument :: [(Text, SimpleArgumentSchema)] -> SimpleArgumentSchema
UnknownArgument :: Text -> SimpleArgumentSchema
toSimpleArgumentSchema :: Schema -> SimpleArgumentSchema
data CompilationError
RawError :: Text -> CompilationError
CompilationError :: !Text -> !Int -> !Int -> ![Text] -> CompilationError
[filename] :: CompilationError -> !Text
[row] :: CompilationError -> !Int
[column] :: CompilationError -> !Int
[text] :: CompilationError -> ![Text]
data PlaygroundError
CompilationErrors :: [CompilationError] -> PlaygroundError
InterpreterError :: [String] -> PlaygroundError
FunctionSchemaError :: PlaygroundError
DecodeJsonTypeError :: String -> String -> PlaygroundError
PlaygroundTimeout :: PlaygroundError
OtherError :: String -> PlaygroundError
parseErrorsText :: Text -> [CompilationError]
parseErrorText :: Text -> CompilationError
consumeTo :: Monad m => Text -> StateT Text m Text
consume :: (Monad m, Monoid s) => StateT s m s

-- | Light <a>breakOn</a>, but consumes the breakpoint text (the
--   <tt>needle</tt>).
breakWith :: Text -> Text -> (Text, Text)
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.PlaygroundError
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.PlaygroundError
instance GHC.Generics.Generic Playground.API.PlaygroundError
instance GHC.Show.Show Playground.API.PlaygroundError
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.CompilationError
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.CompilationError
instance GHC.Generics.Generic Playground.API.CompilationError
instance GHC.Classes.Eq Playground.API.CompilationError
instance GHC.Show.Show Playground.API.CompilationError
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.SimpleArgumentSchema
instance GHC.Generics.Generic Playground.API.SimpleArgumentSchema
instance GHC.Classes.Eq Playground.API.SimpleArgumentSchema
instance GHC.Show.Show Playground.API.SimpleArgumentSchema
instance GHC.Base.Functor Playground.API.FunctionSchema
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Playground.API.FunctionSchema a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Playground.API.FunctionSchema a)
instance GHC.Generics.Generic (Playground.API.FunctionSchema a)
instance GHC.Show.Show a => GHC.Show.Show (Playground.API.FunctionSchema a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Playground.API.FunctionSchema a)
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.EvaluationResult
instance GHC.Generics.Generic Playground.API.EvaluationResult
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.Evaluation
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.Evaluation
instance GHC.Generics.Generic Playground.API.Evaluation
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.Expression
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.Expression
instance GHC.Generics.Generic Playground.API.Expression
instance GHC.Show.Show Playground.API.Expression
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.Fn
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.Fn
instance Language.Haskell.TH.Syntax.Lift Playground.API.Fn
instance GHC.Generics.Generic Playground.API.Fn
instance GHC.Show.Show Playground.API.Fn
instance GHC.Classes.Eq Playground.API.Fn
instance Control.Newtype.Generics.Newtype Playground.API.SourceCode
instance Data.Aeson.Types.FromJSON.FromJSON Playground.API.SourceCode
instance Data.Aeson.Types.ToJSON.ToJSON Playground.API.SourceCode
instance GHC.Generics.Generic Playground.API.SourceCode

module Playground.Interpreter.Util

-- | Unfortunately any uncaught errors in the interpreter kill the thread
--   that is running it rather than returning the error. This means we need
--   to handle all expected errors in the expression we are interpreting.
--   This gets a little tricky because we have to decode JSON inside the
--   interpreter (since we don't have access to it's type outside) so we
--   need to wrap the @apply functions up in something that can throw
--   errors.
runTrace :: [(Wallet, Int)] -> [Either PlaygroundError (Trace MockWallet [Tx])] -> Either PlaygroundError (Blockchain, [EmulatorEvent], [(Wallet, Value)])

-- | This will throw an exception if it cannot decode the json however it
--   should never do this as long as it is only called in places where we
--   have already decoded and encoded the value since it came from an HTTP
--   API call
decode' :: (FromJSON a, Typeable a) => String -> a
decode :: (FromJSON a, Typeable a, MonadError PlaygroundError m) => String -> m a
apply :: (MonadError PlaygroundError m) => a -> m a
apply1 :: (Typeable a, FromJSON a, MonadError PlaygroundError m) => (a -> b) -> String -> m b
apply2 :: (Typeable a, FromJSON a, Typeable b, FromJSON b, MonadError PlaygroundError m) => (a -> b -> c) -> String -> String -> m c
apply3 :: (Typeable a, Typeable a, FromJSON a, Typeable b, FromJSON b, Typeable c, FromJSON c, MonadError PlaygroundError m) => (a -> b -> c -> d) -> String -> String -> String -> m d
apply4 :: (Typeable a, FromJSON a, Typeable b, FromJSON b, Typeable c, FromJSON c, Typeable d, FromJSON d, MonadError PlaygroundError m) => (a -> b -> c -> d -> e) -> String -> String -> String -> String -> m e
apply5 :: (Typeable a, FromJSON a, Typeable b, FromJSON b, Typeable c, FromJSON c, Typeable d, FromJSON d, Typeable e, FromJSON e, MonadError PlaygroundError m) => (a -> b -> c -> d -> e -> f) -> String -> String -> String -> String -> String -> m f
apply6 :: (Typeable a, FromJSON a, Typeable b, FromJSON b, Typeable c, FromJSON c, Typeable d, FromJSON d, Typeable e, FromJSON e, Typeable f, FromJSON f, MonadError PlaygroundError m) => (a -> b -> c -> d -> e -> f -> g) -> String -> String -> String -> String -> String -> String -> m g
apply7 :: (Typeable a, FromJSON a, Typeable b, FromJSON b, Typeable c, FromJSON c, Typeable d, FromJSON d, Typeable e, FromJSON e, Typeable f, FromJSON f, Typeable g, FromJSON g, MonadError PlaygroundError m) => (a -> b -> c -> d -> e -> f -> g -> h) -> String -> String -> String -> String -> String -> String -> String -> m h

module Playground.TH
mkFunction :: Name -> Q [Dec]
mkFunctions :: [Name] -> Q [Dec]
mkSingleFunction :: Name -> Q [Dec]


-- | Re-export functions that are needed when creating a Contract for use
--   in the playground
module Playground.Contract
mkFunctions :: [Name] -> Q [Dec]
mkFunction :: Name -> Q [Dec]
class ToSchema a
data Schema
class ToJSON a
class FromJSON a
data FunctionSchema a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | Transfer some funds to an address locked by a public key
payToPublicKey_ :: (Monad m, WalletAPI m) => Value -> PubKey -> m ()
data MockWallet a

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A lazy <a>ByteString</a> contains 8-bit bytes, or by using the
--   operations from <a>Data.ByteString.Lazy.Char8</a> it can be
--   interpreted as containing 8-bit characters.
data ByteString
printSchemas :: [FunctionSchema Schema] -> IO ()
printJson :: ToJSON a => a -> IO ()
newtype Wallet
Wallet :: Int -> Wallet
[getWallet] :: Wallet -> Int

-- | Add a number of blocks, notifying all wallets after each block
addBlocksAndNotify :: () => [Wallet] -> Int -> Trace m ()
runWalletActionAndProcessPending :: () => [Wallet] -> Wallet -> m () -> Trace m [Tx]
instance Data.ByteArray.Types.ByteArrayAccess Data.ByteString.Lazy.Internal.ByteString
