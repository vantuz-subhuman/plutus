-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language library for Plutus Core
--   
--   Pretty-printer, parser, and typechecker for Plutus Core.
@package language-plutus-core
@version 0.1.0.0


-- | Hash functions for lazy [[Data.ByteString.Lazy.ByteString]]s
module Data.ByteString.Lazy.Hash

-- | Hash a [[BSL.ByteString]] using the SHA-256 hash function.
sha2 :: ByteString -> ByteString

-- | Hash a [[BSL.ByteString]] using the SHA3-256 hash function.
sha3 :: ByteString -> ByteString

module PlutusPrelude

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> a -> b -> b
infixl 1 &

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: () => a -> a -> Bool -> a

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => a -> b -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => b -> c -> p a b -> p a c
on :: () => b -> b -> c -> a -> b -> a -> a -> c
infixl 0 `on`

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => b -> a -> b -> b -> t a -> b

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: Exception e => e -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m m a -> m a

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => b -> m c -> a -> m b -> a -> m c
infixr 1 <=<

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: () => b -> Either a b -> b

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: () => Either a b -> Bool

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Makes an effectful function ignore its result value and return its
--   input value.
through :: Functor f => (a -> f b) -> (a -> f a)

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | A class of types that can be fully evaluated.
class NFData a

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^20 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a

-- | 8-bit unsigned integer type
data Word8

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: * -> *)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
newtype PairT b f a
PairT :: f (b, a) -> PairT b f a
[unPairT] :: PairT b f a -> f (b, a)

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k0) (b :: k0)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
type Lens' s a = Lens s s a a
lens :: () => s -> a -> s -> b -> t -> Lens s t a b
(^.) :: () => s -> Getting a s a -> a
view :: MonadReader s m => Getting a s a -> m a
(.~) :: () => ASetter s t a b -> b -> s -> t
set :: () => ASetter s t a b -> b -> s -> t
(%~) :: () => ASetter s t a b -> a -> b -> s -> t
over :: () => ASetter s t a b -> a -> b -> s -> t

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a
(.*) :: () => c -> d -> a -> b -> c -> a -> b -> d
(<<$>>) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<$>>
(<<*>>) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<*>>

-- | Fold a monadic function over a <a>Foldable</a>. The monadic version of
--   <a>foldMap</a>.
foldMapM :: (Foldable f, Monad m, Monoid b) => (a -> m b) -> f a -> m b

-- | Make sure your <a>Applicative</a> is sufficiently lazy!
repeatM :: Applicative f => Int -> f a -> f [a]
(?) :: Alternative f => Bool -> a -> f a
infixr 2 ?

-- | Like a version of <tt>everywhere</tt> for recursion schemes.
hoist :: (Recursive t, Corecursive t) => (Base t t -> Base t t) -> t -> t
(<+>) :: () => Doc ann -> Doc ann -> Doc ann
parens :: () => Doc ann -> Doc ann
brackets :: () => Doc ann -> Doc ann
hardline :: () => Doc ann
squotes :: () => Doc ann -> Doc ann
list :: () => [Doc ann] -> Doc ann
data Doc ann
strToBs :: String -> ByteString
bsToStr :: ByteString -> String
indent :: () => Int -> Doc ann -> Doc ann
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | This class is used in order to provide default implementations of
--   <a>PrettyBy</a> for particular <tt>config</tt>s. Whenever a
--   <tt>Config</tt> is a sum type of <tt>Subconfig1</tt>,
--   <tt>Subconfig2</tt>, etc, we can define a single
--   <a>DefaultPrettyBy</a> instance and then derive <tt>PrettyBy Config
--   a</tt> for each <tt>a</tt> provided the <tt>a</tt> implements the
--   <tt>PrettyBy Subconfig1</tt>, <tt>PrettyBy Subconfig2</tt>, etc
--   instances.
--   
--   Example:
--   
--   <pre>
--   data Config = Subconfig1 Subconfig1 | Subconfig2 Subconfig2
--   
--   instance (PrettyBy Subconfig1 a, PrettyBy Subconfig2 a) =&gt; DefaultPrettyBy Config a where
--       defaultPrettyBy (Subconfig1 subconfig1) = prettyBy subconfig1
--       defaultPrettyBy (Subconfig2 subconfig2) = prettyBy subconfig2
--   </pre>
--   
--   Now having in scope <tt>PrettyBy Subconfig1 A</tt> and <tt>PrettyBy
--   Subconfig2 A</tt> and the same instances for <tt>B</tt> we can write
--   
--   <pre>
--   instance PrettyBy Config A
--   instance PrettyBy Config B
--   </pre>
--   
--   and the instances will be derived for us.
class DefaultPrettyBy config a
defaultPrettyBy :: DefaultPrettyBy config a => config -> a -> Doc ann

-- | Overloaded configurable conversion to <a>Doc</a>. I.e. like
--   <a>Pretty</a>, but parameterized by a <tt>config</tt>. This class is
--   interoperable with the <a>Pretty</a> class via
--   <a>PrettyConfigIgnore</a> and <tt>PrettyConfigAttatch</tt>.
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyBy :: (PrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | A newtype wrapper around <tt>a</tt> which point is to provide a
--   'PrettyBy config' instance for anything that has a <a>Pretty</a>
--   instance.
newtype PrettyConfigIgnore a
PrettyConfigIgnore :: a -> PrettyConfigIgnore a
[unPrettyConfigIgnore] :: PrettyConfigIgnore a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a 'PrettyBy config'
--   instance.
data PrettyConfigAttach config a
PrettyConfigAttach :: config -> a -> PrettyConfigAttach config a

-- | Render a <a>Doc</a> as <a>String</a>.
docString :: Doc a -> String

-- | Render a <a>Doc</a> as <tt>Text</tt>.
docText :: Doc a -> Text

-- | Render a value as <a>String</a>.
prettyString :: Pretty a => a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyText :: Pretty a => a -> Text

-- | Render a value as <a>String</a>.
prettyStringBy :: PrettyBy config a => config -> a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyTextBy :: PrettyBy config a => config -> a -> Text

-- | This prints a document enclosed by brackets, possibly indenting the
--   output on a new line if it does not fit.
brackets' :: Doc a -> Doc a

-- | This prints a document enclosed by braces, possibly indenting the
--   output on a new line if it does not fit.
braces' :: Doc a -> Doc a

-- | This is the same as <a>vsep</a>, but it <a>group</a>s the output, so
--   that documents are printed on the same line when possible.
vsep' :: [Doc a] -> Doc a

-- | This prints a document enclosed by parentheses, aligning the opening
--   and closing parentheses.
parens' :: Doc a -> Doc a

-- | This prints both documents on the same line separated by a space if
--   they can fit, and behaves like <a>&lt;//&gt;</a> otherwise.
(</>) :: Doc a -> Doc a -> Doc a
infixr 5 </>

-- | This operator prints <tt>a</tt> and then prints <tt>b</tt> indented on
--   a new line
(<//>) :: Doc a -> Doc a -> Doc a
infixr 5 <//>

-- | The integer square root. Throws an <a>error</a> on negative input.
isqrt :: Integer -> Integer

-- | The integer square root that acts on negative numbers like this:
--   
--   <pre>
--   &gt;&gt;&gt; iasqrt (-4)
--   -2
--   </pre>
iasqrt :: Integer -> Integer

-- | Compute the maximal <tt>p</tt> such that <tt>b ^ p &lt;= x</tt>.
ilogFloor :: Integer -> Integer -> Integer

-- | Compute the minimal <tt>p</tt> such that <tt>x &lt;= b ^ p</tt>.
ilogRound :: Integer -> Integer -> Integer

-- | A command suitable for use in GHCi as an interactive printer.
printPretty :: Pretty a => a -> IO ()
showText :: Show a => a -> Text
instance GHC.Base.Functor f => GHC.Base.Functor (PlutusPrelude.PairT b f)
instance PlutusPrelude.PrettyBy config a => Data.Text.Prettyprint.Doc.Internal.Pretty (PlutusPrelude.PrettyConfigAttach config a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty a => PlutusPrelude.PrettyBy config (PlutusPrelude.PrettyConfigIgnore a)
instance PlutusPrelude.PrettyBy config a => PlutusPrelude.PrettyBy config [a]

module Language.PlutusCore.Name

-- | An <a>IdentifierState</a> includes a map indexed by <a>Int</a>s as
--   well as a map indexed by <tt>ByteString</tt>s. It is used during
--   parsing and renaming.
type IdentifierState = (IntMap ByteString, Map ByteString Unique, Unique)

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | The unique of a type-level name.
newtype TypeUnique
TypeUnique :: Unique -> TypeUnique
[unTypeUnique] :: TypeUnique -> Unique

-- | The unique of a term-level name.
newtype TermUnique
TermUnique :: Unique -> TermUnique
[unTermUnique] :: TermUnique -> Unique

-- | Types which have a <a>Unique</a> attached to them, mostly names.
class Coercible Unique unique => HasUnique a unique | a -> unique
unique :: HasUnique a unique => Lens' a unique

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name a
Name :: a -> Text -> Unique -> Name a
[nameAttribute] :: Name a -> a

-- | The identifier name, for use in error messages.
[nameString] :: Name a -> Text

-- | A <a>Unique</a> assigned to the name during lexing, allowing for cheap
--   comparisons in the compiler.
[nameUnique] :: Name a -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName a
TyName :: Name a -> TyName a
[unTyName] :: TyName a -> Name a

-- | This is a naïve implementation of interned identifiers. In particular,
--   it indexes things twice (once by <a>Int</a>, once by
--   <tt>ByteString</tt>) to ensure fast lookups while lexing and
--   otherwise.
newIdentifier :: (MonadState IdentifierState m) => ByteString -> m Unique
emptyIdentifierState :: IdentifierState
identifierStateFrom :: Unique -> IdentifierState

-- | Apply a function to the string representation of a <a>Name</a>.
mapNameString :: (Text -> Text) -> Name a -> Name a

-- | Apply a function to the string representation of a <a>TyName</a>.
mapTyNameString :: (Text -> Text) -> TyName a -> TyName a

-- | The default implementation of <a>HasUnique</a> for newtypes.
newtypeUnique :: (Wrapped new, HasUnique (Unwrapped new) unique', Coercible unique' unique) => Lens' new unique

-- | A config that determines how to pretty-print a PLC name.
data PrettyConfigName
PrettyConfigName :: Bool -> Bool -> PrettyConfigName

-- | Whether to show the <a>Unique</a> of a <a>Name</a> or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | Whether to show the "With" part of a name or not. E.g. for
--   <tt>TyNameWithKind</tt> this flag controls whether the <tt>Kind</tt>
--   is shown or not.
[_pcnShowsAttached] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print neither
--   <a>Unique</a>s, nor name attachments.
defPrettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> used for debugging: print <a>Unique</a>s,
--   but not name attachments.
debugPrettyConfigName :: PrettyConfigName
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.PlutusCore.Name.TyName a)
instance GHC.Base.Functor Language.PlutusCore.Name.TyName
instance GHC.Classes.Ord (Language.PlutusCore.Name.TyName a)
instance GHC.Classes.Eq (Language.PlutusCore.Name.TyName a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Language.PlutusCore.Name.TyName a)
instance GHC.Generics.Generic (Language.PlutusCore.Name.TyName a)
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Name.TyName a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Language.PlutusCore.Name.Name a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.PlutusCore.Name.Name a)
instance GHC.Generics.Generic (Language.PlutusCore.Name.Name a)
instance GHC.Base.Functor Language.PlutusCore.Name.Name
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Name.Name a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Name.Unique
instance Control.DeepSeq.NFData Language.PlutusCore.Name.Unique
instance Language.Haskell.TH.Syntax.Lift Language.PlutusCore.Name.Unique
instance GHC.Classes.Ord Language.PlutusCore.Name.Unique
instance GHC.Show.Show Language.PlutusCore.Name.Unique
instance GHC.Classes.Eq Language.PlutusCore.Name.Unique
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.Name.TyName a)
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.Name.Name a)
instance Language.PlutusCore.Name.HasUnique (Language.PlutusCore.Name.Name a) Language.PlutusCore.Name.TermUnique
instance Language.PlutusCore.Name.HasUnique (Language.PlutusCore.Name.TyName a) Language.PlutusCore.Name.TypeUnique
instance Control.Lens.Wrapped.Wrapped (Language.PlutusCore.Name.TyName a)
instance GHC.Classes.Eq (Language.PlutusCore.Name.Name a)
instance GHC.Classes.Ord (Language.PlutusCore.Name.Name a)


-- | Various views of PLC entities.
module Language.PlutusCore.View

-- | A function (called "head") applied to a list of arguments (called
--   "spine").
data IterApp head arg
IterApp :: head -> [arg] -> IterApp head arg
[_iterAppHead] :: IterApp head arg -> head
[_iterAppSpine] :: IterApp head arg -> [arg]

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
type TermIterApp tyname name a = IterApp (Term tyname name a) (Term tyname name a)

-- | An iterated application of a <a>BuiltinName</a> to a list of
--   <a>Value</a>s.
type PrimIterApp tyname name a = IterApp StagedBuiltinName (Value tyname name a)

-- | View a <a>Constant</a> as an <a>Integer</a>.
constantAsInteger :: Constant a -> Maybe Integer

-- | View a <a>Constant</a> as a <a>StagedBuiltinName</a>.
constantAsStagedBuiltinName :: Builtin a -> StagedBuiltinName

-- | View a <a>Term</a> as a <a>Constant</a>.
termAsBuiltin :: Term tyname name a -> Maybe (Builtin a)

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
termAsTermIterApp :: Term tyname name a -> TermIterApp tyname name a

-- | View a <a>Term</a> as an iterated application of a <a>BuiltinName</a>
--   to a list of <a>Value</a>s.
termAsPrimIterApp :: Term tyname name a -> Maybe (PrimIterApp tyname name a)
instance (PlutusPrelude.PrettyBy config head, PlutusPrelude.PrettyBy config arg) => PlutusPrelude.PrettyBy config (Language.PlutusCore.View.IterApp head arg)

module Language.PlutusCore.Subst

-- | Naively substitute names using the given functions (i.e. do not
--   account for scoping).
substTerm :: (tyname a -> Maybe (Type tyname a)) -> (name a -> Maybe (Term tyname name a)) -> Term tyname name a -> Term tyname name a

-- | Naively substitute names using the given function (i.e. do not account
--   for scoping).
substTy :: (tyname a -> Maybe (Type tyname a)) -> Type tyname a -> Type tyname a

-- | Get all the free term variables in a term.
fvTerm :: (Ord (name a)) => Term tyname name a -> Set (name a)

-- | Get all the free type variables in a term.
ftvTerm :: (Ord (tyname a)) => Term tyname name a -> Set (tyname a)

-- | Get all the free type variables in a type.
ftvTy :: (Ord (tyname a)) => Type tyname a -> Set (tyname a)

module Language.PlutusCore.Quote

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: (Monad m) => QuoteT m a -> m a

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: Monad m => a -> Text -> QuoteT m (Name a)

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: Monad m => a -> Text -> QuoteT m (TyName a)

-- | Make a copy of the given <a>Name</a> that is distinct from the old
--   one.
freshenName :: Monad m => Name a -> QuoteT m (Name a)

-- | Make a copy of the given <a>TyName</a> that is distinct from the old
--   one.
freshenTyName :: Monad m => TyName a -> QuoteT m (TyName a)

-- | Mark a given <a>Unique</a> (and implicitly all <a>Unique</a>s less
--   than it) as used, so they will not be generated in future.
markNonFresh :: MonadQuote m => Unique -> m ()

-- | Marks all the <a>Unique</a>s in a term as used, so they will not be
--   generated in future. Useful if you have a term which was not generated
--   in <a>Quote</a>.
markNonFreshTerm :: (HasUnique (tyname a) TypeUnique, HasUnique (name a) TermUnique, MonadQuote m) => Term tyname name a -> m ()

-- | Marks all the <a>Unique</a>s in a type as used, so they will not be
--   generated in future. Useful if you have a type which was not generated
--   in <a>Quote</a>.
markNonFreshType :: (HasUnique (tyname a) TypeUnique, MonadQuote m) => Type tyname a -> m ()

-- | Marks all the <a>Unique</a>s in a program as used, so they will not be
--   generated in future. Useful if you have a program which was not
--   generated in <a>Quote</a>.
markNonFreshProgram :: (HasUnique (tyname a) TypeUnique, HasUnique (name a) TermUnique, MonadQuote m) => Program tyname name a -> m ()

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m

-- | The state contains the "next" <a>Unique</a> that should be used for a
--   name
type FreshState = Unique
liftQuote :: MonadQuote m => Quote a -> m a
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Language.PlutusCore.Quote.QuoteT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState Language.PlutusCore.Quote.FreshState (Language.PlutusCore.Quote.QuoteT m)
instance Control.Monad.Morph.MFunctor Language.PlutusCore.Quote.QuoteT
instance Control.Monad.Trans.Class.MonadTrans Language.PlutusCore.Quote.QuoteT
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => Language.PlutusCore.Quote.MonadQuote (Language.PlutusCore.Quote.QuoteT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.State.Lazy.StateT s m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Maybe.MaybeT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Except.ExceptT e m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Reader.ReaderT r m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Gen.GenT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Property.PropertyT m)

module Language.PlutusCore.MkPlc

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name a
VarDecl :: a -> name a -> Type tyname a -> VarDecl tyname name a
[varDeclAnn] :: VarDecl tyname name a -> a
[varDeclName] :: VarDecl tyname name a -> name a
[varDeclType] :: VarDecl tyname name a -> Type tyname a

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname a
TyVarDecl :: a -> tyname a -> Kind a -> TyVarDecl tyname a
[tyVarDeclAnn] :: TyVarDecl tyname a -> a
[tyVarDeclName] :: TyVarDecl tyname a -> tyname a
[tyVarDeclKind] :: TyVarDecl tyname a -> Kind a

-- | A "type declaration", i.e. a kind for a type.
data TyDecl tyname a
TyDecl :: a -> Type tyname a -> Kind a -> TyDecl tyname a
[tyDeclAnn] :: TyDecl tyname a -> a
[tyDeclType] :: TyDecl tyname a -> Type tyname a
[tyDeclKind] :: TyDecl tyname a -> Kind a

-- | Make a <a>Var</a> referencing the given <a>VarDecl</a>.
mkVar :: a -> VarDecl tyname name a -> Term tyname name a

-- | Make a <a>TyVar</a> referencing the given <a>TyVarDecl</a>.
mkTyVar :: a -> TyVarDecl tyname a -> Type tyname a
tyDeclVar :: TyVarDecl tyname a -> TyDecl tyname a

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val

-- | A term definition as a variable.
type TermDef tyname name a = Def (VarDecl tyname name a) (Term tyname name a)

-- | A type definition as a type variable.
type TypeDef tyname a = Def (TyVarDecl tyname a) (Type tyname a)

-- | The type of a PLC function.
data FunctionType tyname ann
FunctionType :: ann -> Type tyname ann -> Type tyname ann -> FunctionType tyname ann

-- | An annotation.
[_functionTypeAnn] :: FunctionType tyname ann -> ann

-- | The domain of a function.
[_functionTypeDom] :: FunctionType tyname ann -> Type tyname ann

-- | The codomain of the function.
[_functionTypeCod] :: FunctionType tyname ann -> Type tyname ann

-- | A PLC function.
data FunctionDef tyname name ann
FunctionDef :: ann -> name ann -> FunctionType tyname ann -> Term tyname name ann -> FunctionDef tyname name ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef tyname name ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef tyname name ann -> name ann

-- | The type of the function.
[_functionDefType] :: FunctionDef tyname name ann -> FunctionType tyname ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef tyname name ann -> Term tyname name ann

-- | Convert a <a>FunctionType</a> to the corresponding <a>Type</a>.
functionTypeToType :: FunctionType tyname ann -> Type tyname ann

-- | Get the type of a <a>FunctionDef</a>.
functionDefToType :: FunctionDef tyname name ann -> Type tyname ann

-- | Convert a <a>FunctionDef</a> to a <a>VarDecl</a>. I.e. ignore the
--   actual term.
functionDefVarDecl :: FunctionDef tyname name ann -> VarDecl tyname name ann

-- | Make a <tt>FunctioDef</tt>. Return <a>Nothing</a> if the provided type
--   is not functional.
mkFunctionDef :: ann -> name ann -> Type tyname ann -> Term tyname name ann -> Maybe (FunctionDef tyname name ann)

-- | Make a "let-binding" for a term.
mkTermLet :: a -> TermDef tyname name a -> Term tyname name a -> Term tyname name a

-- | Make a "let-binding" for a type. Note: the body must be a value.
mkTypeLet :: a -> TypeDef tyname a -> Term tyname name a -> Term tyname name a

-- | Universally quantify a list of names.
mkIterTyForall :: [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterTyLam :: [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Make an iterated application.
mkIterApp :: a -> Term tyname name a -> [Term tyname name a] -> Term tyname name a

-- | Make an iterated function type.
mkIterTyFun :: a -> [Type tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterLamAbs :: [VarDecl tyname name a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated instantiation.
mkIterInst :: a -> Term tyname name a -> [Type tyname a] -> Term tyname name a

-- | Type abstract a list of names.
mkIterTyAbs :: [TyVarDecl tyname a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated type application.
mkIterTyApp :: a -> Type tyname a -> [Type tyname a] -> Type tyname a

-- | Make an iterated function kind.
mkIterKindArrow :: a -> [Kind a] -> Kind a -> Kind a
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Ord var, GHC.Classes.Ord val) => GHC.Classes.Ord (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Eq var, GHC.Classes.Eq val) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Show.Show var, GHC.Show.Show val) => GHC.Show.Show (Language.PlutusCore.MkPlc.Def var val)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance (GHC.Classes.Ord (tyname a), GHC.Classes.Eq a) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance (GHC.Show.Show a, GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance GHC.Base.Functor tyname => GHC.Base.Functor (Language.PlutusCore.MkPlc.TyDecl tyname)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (tyname a)) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (GHC.Show.Show a, GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance GHC.Base.Functor tyname => GHC.Base.Functor (Language.PlutusCore.MkPlc.TyVarDecl tyname)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Classes.Ord (tyname a), GHC.Classes.Eq a, GHC.Classes.Eq (name a)) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Show.Show a, GHC.Show.Show (name a), GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Base.Functor name, GHC.Base.Functor tyname) => GHC.Base.Functor (Language.PlutusCore.MkPlc.VarDecl tyname name)


-- | Machinery defined in this module allows to export mulptiple Plutus
--   Core definitions (types and terms) as a single value which enables
--   convenient testing of various procedures (pretty-printing, type
--   checking, etc): each time a function / data type is added to that
--   value, none of the tests is required to be adapted, instead all the
--   tests see the new definition automatically.
module Language.PlutusCore.FsTree

-- | An <a>FsTree</a> is either a file or a folder with a list of
--   <a>FsTree</a>s inside.
data FsTree a
FsFolder :: String -> (FolderContents a) -> FsTree a
FsFile :: String -> a -> FsTree a

-- | The contents of a folder. A wrapper around <tt>[FsTree a]</tt>. Exists
--   because of its <a>Semigroup</a> instance which allows to concatenate
--   two <a>FolderContents</a>s without placing them into the same folder
--   immediately, so we can have various PLC "modules" (<tt>stdlib</tt>,
--   <tt>examples</tt>, etc), define compound modules (e.g. <tt>stdlib
--   &lt;&gt; examples</tt>) and run various tests (pretty-printing, type
--   synthesis, etc) against simple and compound modules uniformly.
newtype FolderContents a
FolderContents :: [FsTree a] -> FolderContents a
[unFolderContents] :: FolderContents a -> [FsTree a]

-- | A <a>PlcEntity</a> is either a <a>Type</a> or a <a>Term</a>.
data PlcEntity
PlcType :: (Quote (Type TyName ())) -> PlcEntity
PlcTerm :: (Quote (Term TyName Name ())) -> PlcEntity
type PlcFsTree = FsTree PlcEntity
type PlcFolderContents = FolderContents PlcEntity

-- | Construct an <a>FsTree</a> out of the name of a folder and a list of
--   <a>FsTree</a>s.
treeFolderContents :: String -> [FsTree a] -> FsTree a

-- | Construct a single-file <a>PlcFsTree</a> out of a type.
plcTypeFile :: String -> Quote (Type TyName ()) -> PlcFsTree

-- | Construct a single-file <a>PlcFsTree</a> out of a term.
plcTermFile :: String -> Quote (Term TyName Name ()) -> PlcFsTree

-- | Fold a <a>FsTree</a>.
foldFsTree :: (String -> [b] -> b) -> (String -> a -> b) -> FsTree a -> b

-- | Fold a <a>PlcFsTree</a>.
foldPlcFsTree :: (String -> [b] -> b) -> (String -> Quote (Type TyName ()) -> b) -> (String -> Quote (Term TyName Name ()) -> b) -> PlcFsTree -> b

-- | Fold the contents of a PLC folder.
foldPlcFolderContents :: (String -> [b] -> b) -> (String -> Quote (Type TyName ()) -> b) -> (String -> Quote (Term TyName Name ()) -> b) -> PlcFolderContents -> [b]
instance GHC.Base.Monoid (Language.PlutusCore.FsTree.FolderContents a)
instance GHC.Base.Semigroup (Language.PlutusCore.FsTree.FolderContents a)

module Language.PlutusCore.Pretty
data Doc ann
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | Overloaded configurable conversion to <a>Doc</a>. I.e. like
--   <a>Pretty</a>, but parameterized by a <tt>config</tt>. This class is
--   interoperable with the <a>Pretty</a> class via
--   <a>PrettyConfigIgnore</a> and <tt>PrettyConfigAttatch</tt>.
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyBy :: (PrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | A newtype wrapper around <tt>a</tt> which point is to provide a
--   'PrettyBy config' instance for anything that has a <a>Pretty</a>
--   instance.
newtype PrettyConfigIgnore a
PrettyConfigIgnore :: a -> PrettyConfigIgnore a
[unPrettyConfigIgnore] :: PrettyConfigIgnore a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a 'PrettyBy config'
--   instance.
data PrettyConfigAttach config a
PrettyConfigAttach :: config -> a -> PrettyConfigAttach config a

-- | Render a <a>Doc</a> as <a>String</a>.
docString :: Doc a -> String

-- | Render a <a>Doc</a> as <tt>Text</tt>.
docText :: Doc a -> Text

-- | Render a value as <a>String</a>.
prettyString :: Pretty a => a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyText :: Pretty a => a -> Text

-- | Render a value as <a>String</a>.
prettyStringBy :: PrettyBy config a => config -> a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyTextBy :: PrettyBy config a => config -> a -> Text

-- | Pretty-print a value in the default mode using the classic view.
prettyPlcDef :: PrettyPlc a => a -> Doc ann

-- | Render a value to <a>String</a> in the default mode using the classic
--   view.
prettyPlcDefString :: PrettyPlc a => a -> String

-- | Render a value to <a>Text</a> in the default mode using the classic
--   view.
prettyPlcDefText :: PrettyPlc a => a -> Text

-- | Whether to pretty-print PLC errors in full or with some information
--   omitted.
data CondensedErrors
CondensedErrorsYes :: CondensedErrors
CondensedErrorsNo :: CondensedErrors

-- | Options for pretty-printing PLC entities.
newtype PrettyConfigPlcOptions
PrettyConfigPlcOptions :: CondensedErrors -> PrettyConfigPlcOptions
[_pcpoCondensedErrors] :: PrettyConfigPlcOptions -> CondensedErrors

-- | Strategy for pretty-printing PLC entities.
data PrettyConfigPlcStrategy
PrettyConfigPlcClassic :: (PrettyConfigClassic PrettyConfigName) -> PrettyConfigPlcStrategy
PrettyConfigPlcReadable :: (PrettyConfigReadable PrettyConfigName) -> PrettyConfigPlcStrategy

-- | Global configuration used for pretty-printing PLC entities.
data PrettyConfigPlc
PrettyConfigPlc :: PrettyConfigPlcOptions -> PrettyConfigPlcStrategy -> PrettyConfigPlc
[_pcpOptions] :: PrettyConfigPlc -> PrettyConfigPlcOptions
[_pcpStrategy] :: PrettyConfigPlc -> PrettyConfigPlcStrategy

-- | The "pretty-printable PLC entity" constraint.
type PrettyPlc = PrettyBy PrettyConfigPlc

-- | The <a>PrettyConfigPlcOptions</a> used by default: print errors in
--   full.
defPrettyConfigPlcOptions :: PrettyConfigPlcOptions

-- | The <a>PrettyConfigPlc</a> used by default: use the classic view and
--   print neither <a>Unique</a>s, nor name attachments.
defPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging: use the classic view
--   and print <a>Unique</a>s, but not name attachments.
debugPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used by default and for readability: use
--   the refined view and print neither <a>Unique</a>s, nor name
--   attachments.
defPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging and readability: use the
--   refined view and print <a>Unique</a>s, but not name attachments.
debugPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | Pretty-print a PLC value in the default mode using the classic view.
prettyPlcClassicDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the classic view.
prettyPlcClassicDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the default mode using the readable view.
prettyPlcReadableDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the readable view.
prettyPlcReadableDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value using the condensed way (see
--   <a>CondensedErrors</a>) of pretty-printing PLC errors (in case there
--   are any).
prettyPlcCondensedErrorBy :: PrettyPlc a => (PrettyConfigPlcOptions -> PrettyConfigPlc) -> a -> Doc ann

-- | Render an error to <a>String</a> in the condensed manner using the
--   classic view.
prettyPlcCondensedErrorClassicString :: PrettyPlc a => a -> String

-- | A config that determines how to pretty-print a PLC name.
data PrettyConfigName
PrettyConfigName :: Bool -> Bool -> PrettyConfigName

-- | Whether to show the <a>Unique</a> of a <a>Name</a> or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | Whether to show the "With" part of a name or not. E.g. for
--   <tt>TyNameWithKind</tt> this flag controls whether the <tt>Kind</tt>
--   is shown or not.
[_pcnShowsAttached] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print neither
--   <a>Unique</a>s, nor name attachments.
defPrettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> used for debugging: print <a>Unique</a>s,
--   but not name attachments.
debugPrettyConfigName :: PrettyConfigName

-- | Configuration for the classic pretty-printing.
newtype PrettyConfigClassic configName
PrettyConfigClassic :: configName -> PrettyConfigClassic configName
[_pccConfigName] :: PrettyConfigClassic configName -> configName

-- | The "classically pretty-printable" constraint.
type PrettyClassicBy configName = PrettyBy (PrettyConfigClassic configName)
type PrettyClassic = PrettyClassicBy PrettyConfigName

-- | Pretty-print a value in the default mode using the classic view.
prettyClassicDef :: PrettyClassic a => a -> Doc ann

-- | A context an expression is rendering in.
data RenderContext
RenderContext :: Fixity -> Direction -> RenderContext
[_rcFixity] :: RenderContext -> Fixity
[_rcDirection] :: RenderContext -> Direction
data ShowKinds
ShowKindsYes :: ShowKinds
ShowKindsNo :: ShowKinds

-- | Configuration for the readable pretty-printing.
data PrettyConfigReadable configName
PrettyConfigReadable :: configName -> RenderContext -> ShowKinds -> PrettyConfigReadable configName
[_pcrConfigName] :: PrettyConfigReadable configName -> configName
[_pcrRenderContext] :: PrettyConfigReadable configName -> RenderContext
[_pcrShowKinds] :: PrettyConfigReadable configName -> ShowKinds

-- | The "readably pretty-printable" constraint.
type PrettyReadableBy configName = PrettyBy (PrettyConfigReadable configName)
type PrettyReadable = PrettyReadableBy PrettyConfigName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>topApp</a>.
topPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>botApp</a>.
botPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Kind a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Constant a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Builtin a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Type tyname a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Type tyname a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Term tyname name a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Term tyname name a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Program tyname name a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Program tyname name a)


-- | This module defines Haskell data types that simplify construction of
--   PLC types and terms.
module Language.PlutusCore.StdLib.Type

-- | A recursive type packaged along with a specified <tt>Wrap</tt> that
--   allows to construct elements of this type.
data RecursiveType ann
RecursiveType :: Type TyName ann -> [Type TyName ann] -> Term TyName Name ann -> Term TyName Name ann -> RecursiveType ann
[_recursiveType] :: RecursiveType ann -> Type TyName ann
[_recursiveWrap] :: RecursiveType ann -> [Type TyName ann] -> Term TyName Name ann -> Term TyName Name ann

-- | Construct a <a>RecursiveType</a> by encoding an n-ary pattern functor
--   as the corresponding 1-ary one and passing it to <a>TyIFix</a> and
--   <a>IWrap</a>. <tt>n</tt> type arguments get packaged together as a
--   CPS-encoded spine.
makeRecursiveType :: FromDataPieces ann (RecursiveType ann)
instance GHC.Show.Show Language.PlutusCore.StdLib.Type.IndicesLengthsMismatchException
instance GHC.Exception.Exception Language.PlutusCore.StdLib.Type.IndicesLengthsMismatchException


-- | This module defines a common type various evaluation machine use to
--   return their results.
module Language.PlutusCore.Evaluation.Result

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())

-- | Map <a>EvaluationSuccess</a> to <a>Just</a> and
--   <a>EvaluationFailure</a> to <a>Nothing</a>.
evaluationResultToMaybe :: EvaluationResult -> Maybe (Value TyName Name ())

-- | Map <a>Just</a> to <a>EvaluationSuccess</a> and <a>Nothing</a> to
--   <a>EvaluationFailure</a>.
maybeToEvaluationResult :: Maybe (Value TyName Name ()) -> EvaluationResult
instance Data.Traversable.Traversable Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance Data.Foldable.Foldable Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Base.Functor Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.PlutusCore.Evaluation.Result.EvaluationResultF a)
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Evaluation.Result.EvaluationResultF a)
instance PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Value Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ()) => PlutusPrelude.PrettyBy config Language.PlutusCore.Evaluation.Result.EvaluationResult
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Applicative Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Base.Monad Language.PlutusCore.Evaluation.Result.EvaluationResultF

module Common

-- | A <a>TestTree</a> of tests under some name prefix.
type TestNested = Reader [String] TestTree

-- | Run a <a>TestTree</a> of tests with a given name prefix.
runTestNestedIn :: [String] -> TestNested -> TestTree

-- | Run a <a>TestTree</a> of tests with an empty prefix.
runTestNested :: TestNested -> TestTree

-- | Descend into a name prefix.
testNested :: String -> [TestNested] -> TestNested

-- | Check the contents of a file against a <a>Text</a>.
goldenVsText :: TestName -> FilePath -> Text -> TestTree

-- | Check the contents of a file against a <a>Text</a>.
goldenVsTextM :: TestName -> FilePath -> IO Text -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDoc :: TestName -> FilePath -> Doc ann -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDocM :: TestName -> FilePath -> IO (Doc ann) -> TestTree

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsText :: TestName -> Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsTextM :: TestName -> IO Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDoc :: TestName -> Doc ann -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDocM :: TestName -> IO (Doc ann) -> TestNested


-- | <tt>tuple</tt>s of various sizees and related functions.
module Language.PlutusCore.StdLib.Meta.Data.Tuple

-- | A Plutus Core tuple.
data Tuple ann
Tuple :: [Type TyName ann] -> Term TyName Name ann -> Tuple ann

-- | The types of elements of a tuple.
[_tupleElementTypes] :: Tuple ann -> [Type TyName ann]

-- | A term representation of the tuple.
[_tupleTerm] :: Tuple ann -> Term TyName Name ann

-- | Get the type of a <a>Tuple</a>.
--   
--   <pre>
--   getTupleType _ (Tuple [a1, ... , an] _) = all r. (a1 -&gt; ... -&gt; an -&gt; r) -&gt; r
--   </pre>
getTupleType :: MonadQuote m => ann -> Tuple ann -> m (Type TyName ann)

-- | Get the type of the ith element of a <a>Tuple</a> along with the
--   element itself.
--   
--   <pre>
--   tupleTypeTermAt _ i (Tuple [a0, ... , an] term) =
--       (ai, term {ai} (\(x0 : a0) ... (xn : an) -&gt; xi))
--   </pre>
tupleTypeTermAt :: MonadQuote m => ann -> Int -> Tuple ann -> m (Type TyName ann, Term TyName Name ann)

-- | Get the ith element of a <a>Tuple</a>.
tupleTermAt :: MonadQuote m => ann -> Int -> Tuple ann -> m (Term TyName Name ann)

-- | Get the ith element of a <a>Tuple</a> as a <a>TermDef</a>.
tupleDefAt :: MonadQuote m => ann -> Int -> Name ann -> Tuple ann -> m (TermDef TyName Name ann)

-- | Bind all elements of a <a>Tuple</a> inside a <a>Term</a>.
--   
--   <pre>
--   bindTuple _ [x_1, ... , x_n] (Tuple [a1, ... , an] term) body =
--       (\(tup : all r. (a_1 -&gt; ... -&gt; a_n -&gt; r) -&gt; r) -&gt;
--         let x_1 = _1 tup
--             ...
--             x_n = _n tup
--           in body
--       ) term
--   </pre>
bindTuple :: MonadQuote m => ann -> [Name ann] -> Tuple ann -> Term TyName Name ann -> m (Term TyName Name ann)

-- | Given an arity <tt>n</tt>, create the n-ary product type.
--   
--   <pre>
--   (T_1 :: *) .. (T_n :: *) . all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R
--   </pre>
getBuiltinProdN :: MonadQuote m => Int -> m (Type TyName ())

-- | Given an arity <tt>n</tt>, create the constructor for n-ary products.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (arg_1 : T_1) .. (arg_n : T_n) .
--           /(R :: *).
--               (case : T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; case arg_1 .. arg_n
--   </pre>
getBuiltinProdNConstructor :: MonadQuote m => Int -> m (Term TyName Name ())

-- | Given an arity <tt>n</tt> and an index <tt>i</tt>, create a function
--   for accessing the i'th component of a n-tuple.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (tuple : all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R)) .
--           tuple {T_i} ((arg_1 : T_1) .. (arg_n : T_n) . arg_i)
--   </pre>
getBuiltinProdNAccessor :: MonadQuote m => Int -> Int -> m (Term TyName Name ())


-- | <tt>unit</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Unit

-- | '()' as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A
--   </pre>
getBuiltinUnit :: Quote (Type TyName ())

-- | '()' as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
getBuiltinUnitval :: Quote (Value TyName Name ())


-- | Combinators.
module Language.PlutusCore.StdLib.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   /\ (A B :: *) -&gt; \(x : A) (y : B) -&gt; x
--   </pre>
getBuiltinConst :: Quote (Term TyName Name ())

-- | <tt>Self</tt> as a PLC type.
--   
--   <pre>
--   fix \(self :: * -&gt; *) (a :: *) -&gt; self a -&gt; a
--   </pre>
getBuiltinSelf :: Quote (RecursiveType ())

-- | <tt>unroll</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(s : self a) -&gt; unwrap s s
--   </pre>
getBuiltinUnroll :: Quote (Term TyName Name ())

-- | <tt>fix</tt> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(f : (a -&gt; b) -&gt; a -&gt; b) -&gt;
--      unroll {a -&gt; b} (iwrap selfF (a -&gt; b) \(s : self (a -&gt; b)) \(x : a) -&gt; f (unroll {a -&gt; b} s) x)
--   </pre>
--   
--   See <tt>plutus<i>docs</i>fomega/z-combinator-benchmarks</tt> for
--   details.
getBuiltinFix :: Quote (Term TyName Name ())

-- | Make a <tt>n</tt>-ary fixpoint combinator.
--   
--   <pre>
--   getBuiltinFixN n :
--   </pre>
--   
--   forall A1 B1 ... An Bn :: * . (forall Q :: * . ((A1 -&gt; B1) -&gt;
--   ... -&gt; (An -&gt; Bn) -&gt; Q) -&gt; (A1 -&gt; B1) -&gt; ... -&gt;
--   (An -&gt; Bn) -&gt; Q) -&gt; (forall R :: * . ((A1 -&gt; B1) -&gt; ...
--   (An -&gt; Bn) -&gt; R) -&gt; R)
getBuiltinFixN :: Int -> Quote (Term TyName Name ())

-- | A PLC function.
data FunctionDef tyname name ann
FunctionDef :: ann -> name ann -> FunctionType tyname ann -> Term tyname name ann -> FunctionDef tyname name ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef tyname name ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef tyname name ann -> name ann

-- | The type of the function.
[_functionDefType] :: FunctionDef tyname name ann -> FunctionType tyname ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef tyname name ann -> Term tyname name ann

-- | Get the fixed-point of a list of mutually recursive functions.
--   
--   <pre>
--   getBuiltinMutualFixOf _ [ FunctionDef _ fN1 (FunctionType _ a1 b1) f1
--                           , ...
--                           , FunctionDef _ fNn (FunctionType _ an bn) fn
--                           ] =
--       Tuple [(a1 -&gt; b1) ... (an -&gt; bn)] $
--           fixN {a1} {b1} ... {an} {bn}
--               /\(q :: *) -&gt; \(choose : (a1 -&gt; b1) -&gt; ... -&gt; (an -&gt; bn) -&gt; q) -&gt;
--                   \(fN1 : a1 -&gt; b1) ... (fNn : an -&gt; bn) -&gt; choose f1 ... fn
--   </pre>
getBuiltinMutualFixOf :: ann -> [FunctionDef TyName Name ann] -> Quote (Tuple ann)


-- | Church-encoded <tt>nat</tt> and related functions.
module Language.PlutusCore.StdLib.Data.ChurchNat

-- | Church-encoded <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   all (r :: *). r -&gt; (r -&gt; r) -&gt; r
--   </pre>
getBuiltinChurchNat :: Quote (Type TyName ())

-- | Church-encoded '0' as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; z
--   </pre>
getBuiltinChurchZero :: Quote (Term TyName Name ())

-- | Church-encoded <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; f (n {r} z f)
--   </pre>
getBuiltinChurchSucc :: Quote (Term TyName Name ())


-- | <tt>boolean</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Bool

-- | <a>Bool</a> as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A -&gt; A
--   </pre>
getBuiltinBool :: Quote (Type TyName ())

-- | <a>True</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x y : A) -&gt; x
--   </pre>
getBuiltinTrue :: Quote (Value TyName Name ())

-- | <a>False</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x y : A) -&gt; y
--   </pre>
getBuiltinFalse :: Quote (Value TyName Name ())

-- | <tt>if_then_else_</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(b : Bool) (x y : () -&gt; A) -&gt; b {() -&gt; A} x y ()
--   </pre>
getBuiltinIf :: Quote (Value TyName Name ())


-- | Normalization of PLC entities.
module Language.PlutusCore.Normalize

-- | The monad transformer that type normalization runs in.
data NormalizeTypeT m tyname ann a

-- | Run a <tt>NormalizeTypeM</tt> computation.
runNormalizeTypeM :: m () -> NormalizeTypeT m tyname ann a -> m a

-- | Run a <tt>NormalizeTypeM</tt> computation without dealing with gas.
runNormalizeTypeDownM :: MonadQuote m => NormalizeTypeT m tyname ann a -> m a

-- | Run a gas-consuming <tt>NormalizeTypeM</tt> computation. Count a
--   single substitution step by subtracting <tt>1</tt> from available gas
--   or fail when there is no available gas.
runNormalizeTypeGasM :: MonadQuote m => Gas -> NormalizeTypeT (StateT Gas (MaybeT m)) tyname ann a -> m (Maybe a)

-- | Locally extend a <a>TypeVarEnv</a> in a <tt>NormalizeTypeM</tt>
--   computation.
withExtendedTypeVarEnv :: (HasUnique (tyname ann) TypeUnique, Monad m) => tyname ann -> NormalizedType tyname ann -> NormalizeTypeT m tyname ann a -> NormalizeTypeT m tyname ann a

-- | Normalize a <a>Type</a> in the <tt>NormalizeTypeM</tt> monad.
normalizeTypeM :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Type tyname ann -> NormalizeTypeT m tyname ann (NormalizedType tyname ann)
normalizeTypeDown :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Type tyname ann -> m (NormalizedType tyname ann)

-- | Substitute a type for a variable in a type and normalize in the
--   <tt>NormalizeTypeM</tt> monad.
substituteNormalizeTypeM :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => NormalizedType tyname ann -> tyname ann -> Type tyname ann -> NormalizeTypeT m tyname ann (NormalizedType tyname ann)

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Term tyname name ann -> NormalizeTypeT m tyname ann (Term tyname name ann)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Language.PlutusCore.Normalize.NormalizeTypeEnv m tyname ann) (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)

module Language.PlutusCore.Check.Uniques
checkProgram :: (Ord a, HasUnique (name a) TermUnique, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Program tyname name a -> m ()
checkTerm :: (Ord a, HasUnique (name a) TermUnique, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Term tyname name a -> m ()
checkType :: (Ord a, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Type tyname a -> m ()


-- | <tt>nat</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Nat

-- | <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   fix \(nat :: *) -&gt; all r. r -&gt; (nat -&gt; r) -&gt; r
--   </pre>
getBuiltinNat :: Quote (RecursiveType ())

-- | '0' as a PLC term.
--   
--   <pre>
--   wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; z
--   </pre>
getBuiltinZero :: Quote (Term TyName Name ())

-- | <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; f n
--   </pre>
getBuiltinSucc :: Quote (Term TyName Name ())

-- | <tt>foldrNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) (z : r) -&gt;
--       fix {nat} {r} \(rec : nat -&gt; r) (n : nat) -&gt;
--           unwrap n {r} z \(n' : nat) -&gt; f (rec n')
--   </pre>
getBuiltinFoldrNat :: Quote (Term TyName Name ())

-- | <tt>foldNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) -&gt;
--       fix {r} {nat -&gt; r} \(rec : r -&gt; nat -&gt; r) (z : r) (n : nat) -&gt;
--           unwrap n {r} z (\(n' : nat) -&gt; rec (f z) n')
--   </pre>
getBuiltinFoldNat :: Quote (Term TyName Name ())

-- | Convert a <tt>nat</tt> to an <tt>integer</tt>.
--   
--   <pre>
--   /\(s :: size) -&gt; \(ss : size s) -&gt;
--       foldNat {integer s}
--           (addInteger {s} (resizeInteger {1} {s} ss 1!1))
--           (resizeInteger {1} {s} ss 1!0)
--   </pre>
getBuiltinNatToInteger :: Quote (Term TyName Name ())


-- | Functions related to <tt>integer</tt>.
module Language.PlutusCore.StdLib.Data.Integer

-- | <tt>succ :: Integer -&gt; Integer</tt> as a PLC term.
--   
--   <pre>
--   /\(s :: size) -&gt; \(i : integer s) -&gt;
--       addInteger {s} i (resizeInteger {1} {s} (sizeOfInteger {s} i) 1!1)
--   </pre>
getBuiltinSuccInteger :: Quote (Term TyName Name ())


-- | <tt>list</tt> and related functions.
module Language.PlutusCore.StdLib.Data.List

-- | <tt>List</tt> as a PLC type.
--   
--   <pre>
--   fix \(list :: * -&gt; *) (a :: *) -&gt; all (r :: *). r -&gt; (a -&gt; list a -&gt; r) -&gt; r
--   </pre>
getBuiltinList :: Quote (RecursiveType ())

-- | '[]' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; z)
--   </pre>
getBuiltinNil :: Quote (Term TyName Name ())

-- | '(:)' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(x : a) (xs : list a) -&gt;
--       wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; f x xs
--   </pre>
getBuiltinCons :: Quote (Term TyName Name ())

-- | <tt>foldrList</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : a -&gt; r -&gt; r) (z : r) -&gt;
--       fix {list a} {r} \(rec : list a -&gt; r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; f x (rec xs')
--   </pre>
getBuiltinFoldrList :: Quote (Term TyName Name ())

-- | 'foldl\'' as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : r -&gt; a -&gt; r) -&gt;
--       fix {r} {list a -&gt; r} \(rec : r -&gt; list a -&gt; r) (z : r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; rec (f z x) xs'
--   </pre>
getBuiltinFoldList :: Quote (Term TyName Name ())

-- | <a>enumFromTo</a> as a PLC term
--   
--   <pre>
--   /\(s :: size) -&gt; (n m : integer s) -&gt;
--       fix {integer s} {list (integer s)}
--           (\(rec : integer s -&gt; list (integer s)) (n' : integer s) -&gt;
--               ifThenElse {list (integer s)}
--                   (greaterThanInteger {integer s} n' m)
--                   (nil {integer s})
--                   (cons {integer s} n' (rec (succInteger {s} n'))))
--           n
--   </pre>
getBuiltinEnumFromTo :: Quote (Term TyName Name ())

-- | <a>sum</a> as a PLC term.
--   
--   <pre>
--   /\(s :: *) -&gt; \(ss : size s) -&gt;
--       foldList {integer s} {integer s} (addInteger {s}) (resizeInteger {1} {s} ss 1!0)
--   </pre>
getBuiltinSum :: Quote (Term TyName Name ())

-- | <a>product</a> as a PLC term.
--   
--   <pre>
--   /\(s :: *) -&gt; \(ss : size s) -&gt;
--       foldList {integer s} {integer s} (multiplyInteger {s}) (resizeInteger {1} {s} ss 1!1)
--   </pre>
getBuiltinProduct :: Quote (Term TyName Name ())


-- | Functions that generate Plutus Core terms from Haskell values and vice
--   versa.
module Language.PlutusCore.StdLib.Meta

-- | Convert an <a>Integer</a> to a <tt>nat</tt>. TODO: convert PLC's
--   <tt>integer</tt> to <tt>nat</tt> instead.
getBuiltinIntegerToNat :: Integer -> Quote (Term TyName Name ())

-- | <tt>sumNat</tt> as a PLC term.
getBuiltinNatSum :: Natural -> Quote (Term TyName Name ())

-- | Convert a Haskell list of <a>Term</a>s to a PLC <tt>list</tt>.
getListToBuiltinList :: Type TyName () -> [Term TyName Name ()] -> Quote (Term TyName Name ())


-- | This module exports everything from the stdlib via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire stdlib in a convenient way: each time a function
--   / data type is added to the stdlib, none of the tests is required to
--   be adapted, instead you just add the new definition to <a>stdLib</a>
--   defined below and all the tests see it automatically.
module Language.PlutusCore.StdLib.Everything

-- | The entire stdlib exported as a single value.
stdLib :: PlcFolderContents

module Language.PlutusCore.TH

-- | A quasiquoter for creating Plutus Core terms.
plcTerm :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core types.
plcType :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core programs.
plcProgram :: QuasiQuoter


-- | Reexports from modules from the <tt>Dynamic</tt> folder.
module Language.PlutusCore.Constant.Dynamic
newtype OnChain (names :: [Symbol]) f (tyname :: * -> *) (name :: * -> *) ann
OnChain :: f tyname name ann -> OnChain f ann
[unOnChain] :: OnChain f ann -> f tyname name ann

-- | The type of evaluators that run on-chain. This is very similar to
--   <a>Evaluator</a>, except an <a>OnChainEvaluator</a> is allowed to
--   return any <tt>r</tt>, not just a <tt>m EvaluationResult</tt> for some
--   <tt>m</tt>. This is because an evaluator running on-chain can perform
--   arbitrary effects and return an arbitrary result containing an
--   <tt>EvaluationResult</tt> somewhere deep inside <tt>r</tt>.
type OnChainEvaluator names f r = DynamicBuiltinNameMeanings -> OnChain names f TyName Name () -> r

-- | The type of functions that transform <a>OnChainEvaluator</a>s.
type OnChainTransformer f names r names' r' = OnChainEvaluator names f r -> OnChainEvaluator names' f r'

-- | The type of handlers of outermost dynamic built-in names.
type OnChainHandler name f r s = forall names. OnChainTransformer f names r (name : names) s
mangleOnChain :: OnChain names f tyname name ann -> OnChain names' f tyname name ann

-- | Interpret a <a>DynamicBuiltinNameMeaning</a> as an
--   <a>OnChainHandler</a> that doesn't change the resulting type of
--   evaluation.
handleDynamicByMeaning :: forall name f r. KnownSymbol name => DynamicBuiltinNameMeaning -> OnChainHandler name f r r
dynamicEmit :: Term tyname name ()
handleDynamicEmit :: OnChainHandler "emit" f r (forall a. (forall size. TypedBuiltin size a) -> IO ([a], r))
dynamicLog :: Term tyname name ()
handleDynamicLog :: OnChainHandler "log" f r (IO ([String], r))
evaluateHandlersBy :: Evaluator f m -> (Evaluator (OnChain '[] f) m -> OnChainEvaluator names f r) -> OnChain names f TyName Name () -> r
newtype PlcList a
PlcList :: [a] -> PlcList a
[unPlcList] :: PlcList a -> [a]
withEmit :: ((a -> IO ()) -> IO b) -> IO ([a], b)
withEmitEvaluateBy :: Evaluator Term m -> (forall size. TypedBuiltin size a) -> (Term TyName Name () -> Term TyName Name ()) -> IO ([a], m EvaluationResult)
dynamicCallAssign :: (forall size. TypedBuiltin size a) -> DynamicBuiltinName -> (a -> IO ()) -> DynamicBuiltinNameDefinition
dynamicCallTypeScheme :: (forall size. TypedBuiltin size a) -> (forall size. TypeScheme size (a -> ()) ())
dynamicCall :: DynamicBuiltinName -> Term tyname name ()
dynamicCharToStringName :: DynamicBuiltinName
dynamicCharToStringMeaning :: DynamicBuiltinNameMeaning
dynamicCharToStringDefinition :: DynamicBuiltinNameDefinition
dynamicCharToString :: Term tyname name ()
dynamicAppendName :: DynamicBuiltinName
dynamicAppendMeaning :: DynamicBuiltinNameMeaning
dynamicAppendDefinition :: DynamicBuiltinNameDefinition
dynamicAppend :: Term tyname name ()
dynamicTraceName :: DynamicBuiltinName


-- | Reexports from modules from the <tt>Constant</tt> folder.
module Language.PlutusCore.Constant

-- | Built-in types indexed by <tt>size</tt>.
data BuiltinSized
BuiltinSizedInt :: BuiltinSized
BuiltinSizedBS :: BuiltinSized
BuiltinSizedSize :: BuiltinSized

-- | Built-in types indexed by <tt>size</tt> along with their denotation.
data TypedBuiltinSized a
[TypedBuiltinSizedInt] :: TypedBuiltinSized Integer
[TypedBuiltinSizedBS] :: TypedBuiltinSized ByteString
[TypedBuiltinSizedSize] :: TypedBuiltinSized ()

-- | Type-level sizes.
data SizeEntry size

-- | A constant size.
SizeValue :: Size -> SizeEntry size

-- | A bound size variable.
SizeBound :: size -> SizeEntry size

-- | Built-in types.
data BuiltinType size
BuiltinSized :: (SizeEntry size) -> BuiltinSized -> BuiltinType size
BuiltinBool :: BuiltinType size

-- | Built-in types. A type is considired "built-in" if it can appear in
--   the type signature of a primitive operation. So <tt>boolean</tt> is
--   considered built-in even though it is defined in PLC and is not
--   primitive.
data TypedBuiltin size a
[TypedBuiltinSized] :: SizeEntry size -> TypedBuiltinSized a -> TypedBuiltin size a
[TypedBuiltinBool] :: TypedBuiltin size Bool
[TypedBuiltinDyn] :: KnownDynamicBuiltinType dyn => TypedBuiltin size dyn

-- | A <a>TypedBuiltin</a> packaged together with a value of the type that
--   the <a>TypedBuiltin</a> denotes.
data TypedBuiltinValue size a
TypedBuiltinValue :: (TypedBuiltin size a) -> a -> TypedBuiltinValue size a

-- | Type schemes of primitive operations. <tt>a</tt> is the Haskell
--   denotation of a PLC type represented as a <a>TypeScheme</a>.
--   <tt>r</tt> is the resulting type in <tt>a</tt>, e.g. the resulting
--   type in <tt>ByteString -&gt; Size -&gt; Integer</tt> is
--   <tt>Integer</tt>.
data TypeScheme size a r
[TypeSchemeBuiltin] :: TypedBuiltin size a -> TypeScheme size a a
[TypeSchemeArrow] :: TypeScheme size a q -> TypeScheme size b r -> TypeScheme size (a -> b) r
[TypeSchemeAllSize] :: (size -> TypeScheme size a r) -> TypeScheme size a r

-- | A <a>BuiltinName</a> with an associated <a>TypeScheme</a>.
data TypedBuiltinName a r
TypedBuiltinName :: BuiltinName -> (forall size. TypeScheme size a r) -> TypedBuiltinName a r

-- | The meaning of a dynamic built-in name consists of its <a>Type</a>
--   represented as a <a>TypeScheme</a> and its Haskell denotation.
data DynamicBuiltinNameMeaning
DynamicBuiltinNameMeaning :: (forall size. TypeScheme size a r) -> a -> DynamicBuiltinNameMeaning

-- | The definition of a dynamic built-in consists of its name and meaning.
data DynamicBuiltinNameDefinition
DynamicBuiltinNameDefinition :: DynamicBuiltinName -> DynamicBuiltinNameMeaning -> DynamicBuiltinNameDefinition

-- | Mapping from <a>DynamicBuiltinName</a>s to their
--   <a>DynamicBuiltinNameMeaning</a>s.
newtype DynamicBuiltinNameMeanings
DynamicBuiltinNameMeanings :: Map DynamicBuiltinName DynamicBuiltinNameMeaning -> DynamicBuiltinNameMeanings
[unDynamicBuiltinNameMeanings] :: DynamicBuiltinNameMeanings -> Map DynamicBuiltinName DynamicBuiltinNameMeaning
type Evaluator f m = DynamicBuiltinNameMeanings -> f TyName Name () -> m EvaluationResult
type Evaluate m = ReaderT (Evaluator Term m) m

-- | Haskell types known to exist on the PLC side.
class KnownDynamicBuiltinType dyn

-- | The type representing <tt>dyn</tt> used on the PLC side.
getTypeEncoding :: KnownDynamicBuiltinType dyn => proxy dyn -> Quote (Type TyName ())

-- | Convert a Haskell value to the corresponding PLC value. <a>Nothing</a>
--   represents a conversion failure.
makeDynamicBuiltin :: KnownDynamicBuiltinType dyn => dyn -> Quote (Maybe (Term TyName Name ()))

-- | Convert a PLC value to the corresponding Haskell value. <a>Nothing</a>
--   represents a conversion failure.
readDynamicBuiltin :: (KnownDynamicBuiltinType dyn, Monad m) => Evaluator Term m -> Term TyName Name () -> m (Maybe dyn)

-- | Convert a <a>TypedBuiltinSized</a> to its untyped counterpart.
eraseTypedBuiltinSized :: TypedBuiltinSized a -> BuiltinSized
runEvaluate :: Evaluator Term m -> Evaluate m a -> m a
withEvaluator :: (Evaluator Term m -> m a) -> Evaluate m a
readDynamicBuiltinM :: (Monad m, KnownDynamicBuiltinType dyn) => Term TyName Name () -> Evaluate m (Maybe dyn)

-- | Typed <a>AddInteger</a>.
typedAddInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>SubtractInteger</a>.
typedSubtractInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>MultiplyInteger</a>.
typedMultiplyInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>DivideInteger</a>.
typedDivideInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>QuotientInteger</a>
typedQuotientInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>ModInteger</a>
typedModInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>RemainderInteger</a>.
typedRemainderInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>LessThanInteger</a>.
typedLessThanInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>LessThanEqInteger</a>.
typedLessThanEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>GreaterThanInteger</a>.
typedGreaterThanInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>GreaterThanEqInteger</a>.
typedGreaterThanEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>EqInteger</a>.
typedEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>ResizeInteger</a>.
typedResizeInteger :: TypedBuiltinName (() -> Integer -> Integer) Integer

-- | Typed <a>IntToByteString</a>.
typedIntToByteString :: TypedBuiltinName (() -> Integer -> ByteString) ByteString

-- | Typed <a>Concatenate</a>.
typedConcatenate :: TypedBuiltinName (ByteString -> ByteString -> ByteString) ByteString

-- | Typed <a>TakeByteString</a>.
typedTakeByteString :: TypedBuiltinName (Integer -> ByteString -> ByteString) ByteString

-- | Typed <a>DropByteString</a>.
typedDropByteString :: TypedBuiltinName (Integer -> ByteString -> ByteString) ByteString

-- | Typed <a>SHA2</a>.
typedSHA2 :: TypedBuiltinName (ByteString -> ByteString) ByteString

-- | Typed <a>SHA3</a>.
typedSHA3 :: TypedBuiltinName (ByteString -> ByteString) ByteString

-- | Typed <a>VerifySignature</a>.
typedVerifySignature :: TypedBuiltinName (ByteString -> ByteString -> ByteString -> Bool) Bool

-- | Typed <a>ResizeByteString</a>.
typedResizeByteString :: TypedBuiltinName (() -> ByteString -> ByteString) ByteString

-- | Typed <a>EqByteString</a>.
typedEqByteString :: TypedBuiltinName (ByteString -> ByteString -> Bool) Bool

-- | Typed <a>TxHash</a>.
typedTxHash :: TypedBuiltinName ByteString ByteString

-- | Typed <a>BlockNum</a>.
typedBlockNum :: TypedBuiltinName (() -> Integer) Integer

-- | Typed <a>SizeOfInteger</a>.
typedSizeOfInteger :: TypedBuiltinName (Integer -> ()) ()

-- | Lift a <a>BuiltinName</a> to <a>Term</a>.
builtinNameAsTerm :: BuiltinName -> Term tyname name ()

-- | Lift a <a>DynamicBuiltinName</a> to <a>Term</a>.
dynamicBuiltinNameAsTerm :: DynamicBuiltinName -> Term tyname name ()

-- | Return the <tt>[-2^(8s - 1), 2^(8s - 1))</tt> bounds for integers of a
--   given <a>Size</a>.
toBoundsInt :: Size -> (Integer, Integer)

-- | Return the <tt>[-2^(8s - 1), 2^(8s - 1) - 1]</tt> bounds for integers
--   of a given <a>Size</a>.
toInclusiveBoundsInt :: Size -> (Integer, Integer)

-- | Check whether an <a>Integer</a> is in the <tt>[-2^(8s - 1), 2^(8s -
--   1))</tt> interval.
checkBoundsInt :: Size -> Integer -> Bool

-- | Check whether the length of a <tt>ByteString</tt> is less than or
--   equal to a given <a>Size</a>.
checkBoundsBS :: Size -> ByteString -> Bool

-- | Compute the size of an <a>Integer</a>. See also <a>toBoundsInt</a>.
sizeOfInteger :: Integer -> Size

-- | Compute the size of a <tt>ByteString</tt>. See also
--   <tt>toBoundsBS</tt>.
sizeOfByteString :: ByteString -> Size

-- | Make a <a>Constant</a> out of an <a>Integer</a>. The size is computed
--   using <a>sizeOfInteger</a>.
makeAutoSizedBuiltinInt :: Integer -> Constant ()

-- | Make a <a>Constant</a> out of a <tt>ByteString</tt>. The size is
--   computed using <tt>sizeOfBS</tt>.
makeAutoSizedBuiltinBS :: ByteString -> Constant ()

-- | Convert a Haskell <a>Integer</a> to the corresponding PLC
--   <tt>integer</tt>.
makeDynBuiltinInt :: Type tyname () -> Term tyname name () -> Integer -> Term tyname name ()

-- | Convert a Haskell <a>Integer</a> to the corresponding PLC
--   <tt>integer</tt>, taking the size singleton from an already existing
--   PLC <tt>integer</tt>.
makeDynBuiltinIntSizedAs :: Type tyname () -> Term tyname name () -> Integer -> Term tyname name ()

-- | Check whether an <a>Integer</a> is in bounds (see
--   <a>checkBoundsInt</a>) and return it as a <a>Constant</a>.
makeBuiltinInt :: Size -> Integer -> Maybe (Constant ())

-- | Check whether a <tt>ByteString</tt> is in bounds (see
--   <a>checkBoundsBS</a>) and return it as a <a>Constant</a>.
makeBuiltinBS :: Size -> ByteString -> Maybe (Constant ())
makeBuiltinStr :: String -> Constant ()

-- | Convert a Haskell value to the corresponding PLC constant indexed by
--   size checking all constraints (e.g. an <a>Integer</a> is in
--   appropriate bounds) along the way.
makeSizedConstant :: Size -> TypedBuiltinSized a -> a -> Maybe (Constant ())

-- | Convert a <a>Bool</a> to the corresponding PLC's <tt>boolean</tt>.
makeBuiltinBool :: Bool -> Quote (Term TyName Name ())

-- | Convert a Haskell value to the corresponding PLC value checking all
--   constraints (e.g. an <a>Integer</a> is in appropriate bounds) along
--   the way.
makeBuiltin :: TypedBuiltinValue Size a -> Quote (Maybe (Term TyName Name ()))

-- | Convert a Haskell value to a PLC value checking all constraints (e.g.
--   an <a>Integer</a> is in appropriate bounds) along the way and fail in
--   case constraints are not satisfied.
unsafeMakeBuiltin :: PrettyDynamic a => TypedBuiltinValue Size a -> Quote (Term TyName Name ())

-- | Convert a Haskell value to a PLC value of a dynamic built-in type.
unsafeMakeDynamicBuiltin :: (KnownDynamicBuiltinType dyn, PrettyDynamic dyn) => dyn -> Quote (Term TyName Name ())

-- | Convert a Haskell value to the corresponding PLC constant indexed by
--   size without checking constraints (e.g. an <a>Integer</a> is in
--   appropriate bounds). This function allows to fake a <a>Constant</a>
--   with a wrong size and thus it's highly unsafe and should be used with
--   great caution.
makeSizedConstantNOCHECK :: Size -> TypedBuiltinSized a -> a -> Constant ()

-- | Convert a Haskell value to the corresponding PLC value without
--   checking constraints (e.g. an <a>Integer</a> is in appropriate
--   bounds). This function allows to fake a <a>Term</a> with a wrong size
--   and thus it's highly unsafe and should be used with great caution.
makeBuiltinNOCHECK :: PrettyDynamic a => TypedBuiltinValue Size a -> Quote (Term TyName Name ())

-- | Extract the <a>Size</a> from a <a>SizeEntry</a>.
flattenSizeEntry :: SizeEntry Size -> Size

-- | Convert a <a>TypedBuiltinSized</a> to its untyped counterpart.
eraseTypedBuiltinSized :: TypedBuiltinSized a -> BuiltinSized

-- | Alter the <a>SizeEntry</a> of a <a>TypedBuiltin</a>.
mapSizeEntryTypedBuiltin :: (SizeEntry size -> SizeEntry size') -> TypedBuiltin size a -> TypedBuiltin size' a

-- | Alter the <tt>size</tt> of a <tt>TypedBuiltin size</tt>.
mapSizeTypedBuiltin :: (size -> size') -> TypedBuiltin size a -> TypedBuiltin size' a

-- | Map each <a>SizeBound</a> to <a>SizeValue</a>.
closeTypedBuiltin :: TypedBuiltin Size a -> TypedBuiltin b a

-- | Convert a <a>TypedBuiltinSized</a> to the corresponding
--   <a>TypeBuiltin</a> and wrap the result in <a>TyBuiltin</a> to get a
--   <a>Type</a>.
typedBuiltinSizedToType :: TypedBuiltinSized a -> Type TyName ()

-- | Apply a continuation to the typed version of a <a>BuiltinSized</a>.
withTypedBuiltinSized :: BuiltinSized -> (forall a. TypedBuiltinSized a -> c) -> c

-- | Apply a continuation to the typed version of a <a>Builtin</a>.
withTypedBuiltin :: BuiltinType size -> (forall a. TypedBuiltin size a -> c) -> c

-- | The resulting <a>TypedBuiltin</a> of a <a>TypeScheme</a>.
typeSchemeResult :: TypeScheme () a r -> TypedBuiltin () r

-- | Convert a <a>TypedBuiltin</a> to the corresponding <a>Type</a>.
typedBuiltinToType :: TypedBuiltin (Type TyName ()) a -> Quote (Type TyName ())

-- | Convert a <a>TypeScheme</a> to the corresponding <a>Type</a>.
--   Basically, a map from the PHOAS representation to the FOAS one.
typeSchemeToType :: TypeScheme (Type TyName ()) a r -> Quote (Type TyName ())

-- | Extract the <a>TypeScheme</a> from a <a>DynamicBuiltinNameMeaning</a>
--   and convert it to the corresponding <a>Type</a>.
dynamicBuiltinNameMeaningToType :: DynamicBuiltinNameMeaning -> Quote (Type TyName ())

-- | Insert a <a>DynamicBuiltinNameDefinition</a> into a
--   <a>DynamicBuiltinNameMeanings</a>.
insertDynamicBuiltinNameDefinition :: DynamicBuiltinNameDefinition -> DynamicBuiltinNameMeanings -> DynamicBuiltinNameMeanings

-- | Apply a continuation to the typed version of a <a>BuiltinName</a>.
withTypedBuiltinName :: BuiltinName -> (forall a r. TypedBuiltinName a r -> c) -> c

-- | Return the <a>Type</a> of a <a>TypedBuiltinName</a>.
typeOfTypedBuiltinName :: TypedBuiltinName a r -> Quote (Type TyName ())

-- | Return the <a>Type</a> of a <a>BuiltinName</a>.
typeOfBuiltinName :: BuiltinName -> Quote (Type TyName ())

-- | Same as the <a>Pretty</a> class, but is specifically for dynamic
--   built-in types as their pretty-printing can be rather weird (see the
--   <tt>PrettyDynamic BSL.ByteString</tt> instance for example).
class PrettyDynamic a
prettyDynamic :: PrettyDynamic a => a -> Doc ann
prettyDynamic :: (PrettyDynamic a, Pretty a) => a -> Doc ann

-- | The type of constant applications errors.
data ConstAppError

-- | A mismatch between expected and actual sizes.
SizeMismatchConstAppError :: Size -> (Constant ()) -> ConstAppError

-- | A mismatch between the type of an argument function expects and its
--   actual type.
IllTypedConstAppError :: BuiltinSized -> (Constant ()) -> ConstAppError

-- | A constant is applied to more arguments than needed in order to
--   reduce. Note that this error occurs even if an expression is
--   well-typed, because constant application is supposed to be computed as
--   soon as there are enough arguments.
ExcessArgumentsConstAppError :: [Value TyName Name ()] -> ConstAppError

-- | An argument of a sized type is not a constant.
SizedNonConstantConstAppError :: (Value TyName Name ()) -> ConstAppError

-- | Could not construct denotation for a built-in.
UnreadableBuiltinConstAppError :: (Value TyName Name ()) -> ConstAppError

-- | The type of constant applications results.
data ConstAppResult

-- | Successfully computed a value.
ConstAppSuccess :: (Value TyName Name ()) -> ConstAppResult

-- | Not enough gas.
ConstAppFailure :: ConstAppResult

-- | Not enough arguments.
ConstAppStuck :: ConstAppResult

-- | An internal error occurred during evaluation.
ConstAppError :: ConstAppError -> ConstAppResult

-- | Same as <a>makeBuiltin</a>, but returns a <a>ConstAppResult</a>.
makeConstAppResult :: TypedBuiltinValue Size a -> Quote ConstAppResult

-- | Apply a function with a known <a>TypeScheme</a> to a list of
--   <a>Constant</a>s (unwrapped from <a>Value</a>s). Checks that the
--   constants are of expected types and there are no size mismatches.
applyTypeSchemed :: Monad m => TypeScheme SizeVar a r -> a -> [Value TyName Name ()] -> QuoteT (Evaluate m) ConstAppResult

-- | Apply a <a>TypedBuiltinName</a> to a list of <a>Constant</a>s
--   (unwrapped from <a>Value</a>s) Checks that the constants are of
--   expected types and there are no size mismatches.
applyBuiltinName :: Monad m => BuiltinName -> [Value TyName Name ()] -> QuoteT (Evaluate m) ConstAppResult


-- | The exceptions that an abstract machine can throw.
module Language.PlutusCore.Evaluation.MachineException

-- | Errors which can occur during a run of an abstract machine.
data MachineError err

-- | An attempt to reduce a not immediately reducible type instantiation.
NonPrimitiveInstantiationMachineError :: MachineError err

-- | An attempt to unwrap a not wrapped term.
NonWrapUnwrappedMachineError :: MachineError err

-- | An attempt to reduce a not immediately reducible application.
NonPrimitiveApplicationMachineError :: MachineError err

-- | An attempt to evaluate an open term.
OpenTermEvaluatedMachineError :: MachineError err

-- | An attempt to compute a constant application resulted in
--   <a>ConstAppError</a>.
ConstAppMachineError :: ConstAppError -> MachineError err
OtherMachineError :: err -> MachineError err

-- | The type of exceptions an abstract machine can throw.
data MachineException err
MachineException :: MachineError err -> Term TyName Name () -> MachineException err

-- | An error.
[_machineExceptionError] :: MachineException err -> MachineError err

-- | A <a>Term</a> that caused the error.
[_machineExceptionCause] :: MachineException err -> Term TyName Name ()
instance GHC.Classes.Eq err => GHC.Classes.Eq (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance GHC.Classes.Eq err => GHC.Classes.Eq (Language.PlutusCore.Evaluation.MachineException.MachineError err)
instance Data.Text.Prettyprint.Doc.Internal.Pretty err => GHC.Show.Show (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance (Data.Text.Prettyprint.Doc.Internal.Pretty err, Data.Typeable.Internal.Typeable err) => GHC.Exception.Exception (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance (PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Constant ()), PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Value Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ()), Data.Text.Prettyprint.Doc.Internal.Pretty err) => PlutusPrelude.PrettyBy config (Language.PlutusCore.Evaluation.MachineException.MachineError err)


-- | The CK machine.
module Language.PlutusCore.Evaluation.CkMachine

-- | The CK machine-specific <a>MachineException</a>.
type CkMachineException = MachineException NoDynamicBuiltinNamesMachineError

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())
applyEvaluateCkBuiltinName :: BuiltinName -> [Value TyName Name ()] -> ConstAppResult

-- | Evaluate a term using the CK machine. May throw a
--   <a>CkMachineException</a>. This differs from the spec version: we do
--   not have the following rule:
--   
--   <pre>
--   s , {_ A} ◁ F ↦ s ◁ W  -- Fully saturated constant, {F A} ~&gt; W.
--   </pre>
--   
--   The reason for that is that the operational semantics of constant
--   applications is unaffected by types as it supports full type erasure,
--   hence <tt>{F A}</tt> can never compute if <tt>F</tt> does not compute,
--   so we simply do not introduce a rule that can't possibly fire.
evaluateCk :: Term TyName Name () -> EvaluationResult

-- | Run a program using the CK machine. May throw a
--   <a>CkMachineException</a>. Calls <a>evaluateCk</a> under the hood, so
--   the same caveats apply.
runCk :: Program TyName Name () -> EvaluationResult
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Evaluation.CkMachine.NoDynamicBuiltinNamesMachineError


-- | Serialise instances for Plutus Core types. Make sure to read the Note
--   [Stable encoding of PLC] before touching anything in this file.
module Language.PlutusCore.CBOR
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.TypeBuiltin
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.BuiltinName
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Name.Unique
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Name.Name a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Name.TyName a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Lexer.Type.Version a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Kind a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Type tyname a)
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.DynamicBuiltinName
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Builtin a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Constant a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Term tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Program tyname name a)
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.AlexPosn

module Language.PlutusCore

-- | Parse a <tt>ByteString</tt> containing a Plutus Core program,
--   returning a <a>ParseError</a> if syntactically invalid.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; parse "(program 0.1.0 [(con addInteger) x y])"
--   Right (Program (AlexPn 1 1 2) (Version (AlexPn 9 1 10) 0 1 0) (Apply (AlexPn 15 1 16) (Apply (AlexPn 15 1 16) (Constant (AlexPn 17 1 18) (BuiltinName (AlexPn 21 1 22) AddInteger)) (Var (AlexPn 33 1 34) (Name {nameAttribute = AlexPn 33 1 34, nameString = "x", nameUnique = Unique {unUnique = 0}}))) (Var (AlexPn 35 1 36) (Name {nameAttribute = AlexPn 35 1 36, nameString = "y", nameUnique = Unique {unUnique = 1}}))))
--   </pre>
parse :: ByteString -> Either (ParseError AlexPosn) (Program TyName Name AlexPosn)
parseST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Program TyName Name AlexPosn)
parseTermST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Term TyName Name AlexPosn)
parseTypeST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Type TyName AlexPosn)

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name AlexPosn)

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseProgram :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name AlexPosn)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Term TyName Name AlexPosn)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Type TyName AlexPosn)

-- | A <a>Term</a> is a value.
data Term tyname name a

-- | A named variable
Var :: a -> (name a) -> Term tyname name a
TyAbs :: a -> (tyname a) -> (Kind a) -> (Term tyname name a) -> Term tyname name a
LamAbs :: a -> (name a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Apply :: a -> (Term tyname name a) -> (Term tyname name a) -> Term tyname name a

-- | A constant term
Constant :: a -> (Constant a) -> Term tyname name a
Builtin :: a -> (Builtin a) -> Term tyname name a
TyInst :: a -> (Term tyname name a) -> (Type tyname a) -> Term tyname name a
Unwrap :: a -> (Term tyname name a) -> Term tyname name a
IWrap :: a -> (Type tyname a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Error :: a -> (Type tyname a) -> Term tyname name a

-- | A <a>Type</a> assigned to expressions.
data Type tyname a
TyVar :: a -> (tyname a) -> Type tyname a
TyFun :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a

-- | Fix-point type, for constructing self-recursive types
TyIFix :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a
TyForall :: a -> (tyname a) -> (Kind a) -> (Type tyname a) -> Type tyname a

-- | Builtin type
TyBuiltin :: a -> TypeBuiltin -> Type tyname a

-- | Type-level size
TyInt :: a -> Natural -> Type tyname a
TyLam :: a -> (tyname a) -> (Kind a) -> (Type tyname a) -> Type tyname a
TyApp :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a

-- | A constant value.
data Constant a
BuiltinInt :: a -> Natural -> Integer -> Constant a
BuiltinBS :: a -> Natural -> ByteString -> Constant a
BuiltinSize :: a -> Natural -> Constant a
BuiltinStr :: a -> String -> Constant a
data Builtin a
BuiltinName :: a -> BuiltinName -> Builtin a
DynBuiltinName :: a -> DynamicBuiltinName -> Builtin a

-- | Kinds. Each type has an associated kind.
data Kind a
Type :: a -> Kind a
KindArrow :: a -> (Kind a) -> (Kind a) -> Kind a
Size :: a -> Kind a

-- | An error encountered during parsing.
data ParseError a
LexErr :: String -> ParseError a
Unexpected :: (Token a) -> ParseError a
Overflow :: a -> Natural -> Integer -> ParseError a

-- | Version of Plutus Core to be used for the program.
data Version a
Version :: a -> Natural -> Natural -> Natural -> Version a

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name a
Program :: a -> (Version a) -> (Term tyname name a) -> Program tyname name a

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name a
Name :: a -> Text -> Unique -> Name a
[nameAttribute] :: Name a -> a

-- | The identifier name, for use in error messages.
[nameString] :: Name a -> Text

-- | A <a>Unique</a> assigned to the name during lexing, allowing for cheap
--   comparisons in the compiler.
[nameUnique] :: Name a -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName a
TyName :: Name a -> TyName a
[unTyName] :: TyName a -> Name a

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int
type Size = Natural
type Value = Term

-- | Builtin functions
data BuiltinName
AddInteger :: BuiltinName
SubtractInteger :: BuiltinName
MultiplyInteger :: BuiltinName
DivideInteger :: BuiltinName
QuotientInteger :: BuiltinName
RemainderInteger :: BuiltinName
ModInteger :: BuiltinName
LessThanInteger :: BuiltinName
LessThanEqInteger :: BuiltinName
GreaterThanInteger :: BuiltinName
GreaterThanEqInteger :: BuiltinName
EqInteger :: BuiltinName
ResizeInteger :: BuiltinName
IntToByteString :: BuiltinName
Concatenate :: BuiltinName
TakeByteString :: BuiltinName
DropByteString :: BuiltinName
ResizeByteString :: BuiltinName
SHA2 :: BuiltinName
SHA3 :: BuiltinName
VerifySignature :: BuiltinName
EqByteString :: BuiltinName
TxHash :: BuiltinName
BlockNum :: BuiltinName
SizeOfInteger :: BuiltinName

-- | The type of dynamic built-in functions. I.e. functions that exist on
--   certain chains and do not exist on others. Each
--   <a>DynamicBuiltinName</a> has an associated type and operational
--   semantics -- this allows to type check and evaluate dynamic built-in
--   names just like static ones.
newtype DynamicBuiltinName
DynamicBuiltinName :: Text -> DynamicBuiltinName

-- | The name of a dynamic built-in name.
[unDynamicBuiltinName] :: DynamicBuiltinName -> Text

-- | Either a <a>BuiltinName</a> (known statically) or a
--   <a>DynamicBuiltinName</a> (known dynamically).
data StagedBuiltinName
StaticStagedBuiltinName :: BuiltinName -> StagedBuiltinName
DynamicStagedBuiltinName :: DynamicBuiltinName -> StagedBuiltinName

-- | A builtin type
data TypeBuiltin
TyByteString :: TypeBuiltin
TyInteger :: TypeBuiltin
TySize :: TypeBuiltin
TyString :: TypeBuiltin
newtype Normalized a
Normalized :: a -> Normalized a
[getNormalized] :: Normalized a -> a
type NormalizedType tyname a = Normalized (Type tyname a)
getNormalizedType :: NormalizedType tyname a -> Type tyname a

-- | The default version of Plutus Core supported by this library.
defaultVersion :: a -> Version a

-- | The list of all <a>BuiltinName</a>s.
allBuiltinNames :: [BuiltinName]
termLoc :: Term tyname name a -> a
tyLoc :: Type tyname a -> a
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn

-- | A function (called "head") applied to a list of arguments (called
--   "spine").
data IterApp head arg
IterApp :: head -> [arg] -> IterApp head arg
[_iterAppHead] :: IterApp head arg -> head
[_iterAppSpine] :: IterApp head arg -> [arg]

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
type TermIterApp tyname name a = IterApp (Term tyname name a) (Term tyname name a)

-- | An iterated application of a <a>BuiltinName</a> to a list of
--   <a>Value</a>s.
type PrimIterApp tyname name a = IterApp StagedBuiltinName (Value tyname name a)
format :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m Text
formatDoc :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m (Doc a)
newtype Gas
Gas :: Natural -> Gas
[unGas] :: Gas -> Natural

-- | Annotate a PLC program, so that all names are annotated with their
--   types/kinds.
annotateProgram :: (AsRenameError e a, MonadError e m) => Program TyName Name a -> m (Program TyNameWithKind NameWithType a)

-- | Annotate a PLC term, so that all names are annotated with their
--   types/kinds.
annotateTerm :: (AsRenameError e a, MonadError e m) => Term TyName Name a -> m (Term TyNameWithKind NameWithType a)

-- | Annotate a PLC type, so that all names are annotated with their
--   types/kinds.
annotateType :: (AsRenameError e a, MonadError e m) => Type TyName a -> m (Type TyNameWithKind a)

-- | A <a>RenameError</a> is thrown when a free variable is encountered
--   during rewriting.
data RenameError a
UnboundVar :: (Name a) -> RenameError a
UnboundTyVar :: (TyName a) -> RenameError a
class AsRenameError r_a1inh a_a1idN | r_a1inh -> a_a1idN
_RenameError :: AsRenameError r_a1inh a_a1idN => Prism' r_a1inh (RenameError a_a1idN)
_UnboundVar :: AsRenameError r_a1inh a_a1idN => Prism' r_a1inh (Name a_a1idN)
_UnboundTyVar :: AsRenameError r_a1inh a_a1idN => Prism' r_a1inh (TyName a_a1idN)
newtype TyNameWithKind a
TyNameWithKind :: TyName (a, Kind a) -> TyNameWithKind a
[unTyNameWithKind] :: TyNameWithKind a -> TyName (a, Kind a)
newtype NameWithType a
NameWithType :: (Name (a, RenamedType a)) -> NameWithType a
data TypeState a
TypeState :: IntMap (RenamedType a) -> IntMap (Kind a) -> TypeState a
[_terms] :: TypeState a -> IntMap (RenamedType a)
[_types] :: TypeState a -> IntMap (Kind a)
type RenamedType a = Type TyNameWithKind a
type RenamedTerm a = Term TyNameWithKind NameWithType a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched. Must always
--   assign new names to bound variables, so that <tt>rename</tt> can be
--   used for alpha renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a
check :: Program tyname name a -> Maybe (NormalizationError tyname name a)

-- | Ensure that all terms and types are well-formed accoring to Fig. 2
checkProgram :: (AsNormalizationError e TyName Name a, MonadError e m) => Program TyName Name a -> m ()

-- | Ensure that all terms and types are well-formed accoring to Fig. 2
checkTerm :: (AsNormalizationError e TyName Name a, MonadError e m) => Term TyName Name a -> m ()
data NormalizationError tyname name a
checkFile :: FilePath -> IO (Maybe Text)
isTypeValue :: Type tyname a -> Bool
isTermValue :: Term tyname name a -> Bool

-- | Type-check a program, returning a normalized type.
typecheckProgram :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Program TyNameWithKind NameWithType a -> m (NormalizedType TyNameWithKind ())

-- | Type-check a term, returning a normalized type.
typecheckTerm :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Term TyNameWithKind NameWithType a -> m (NormalizedType TyNameWithKind ())

-- | Kind-check a PLC type.
kindCheck :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Type TyNameWithKind a -> m (Kind ())

-- | Extract the <a>TypeScheme</a> from a <a>DynamicBuiltinNameMeaning</a>
--   and convert it to the corresponding <tt>Type TyName</tt> for each row
--   of a <a>DynamicBuiltinNameMeanings</a>.
dynamicBuiltinNameMeaningsToTypes :: DynamicBuiltinNameMeanings -> DynamicBuiltinNameTypes

-- | Given a file at <tt>fibonacci.plc</tt>, <tt>fileType
--   "fibonacci.plc"</tt> will display its type or an error message.
fileType :: FilePath -> IO Text
fileNormalizeType :: Bool -> FilePath -> IO Text

-- | Given a file, display its type or an error message, optionally dumping
--   annotations and debug information.
fileTypeCfg :: PrettyConfigPlc -> FilePath -> IO Text

-- | Print the type of a program contained in a <tt>ByteString</tt>
printType :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, AsRenameError e AlexPosn, AsTypeError e AlexPosn, MonadError e m) => ByteString -> m Text

-- | Print the type of a program contained in a <tt>ByteString</tt>
printNormalizeType :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, AsRenameError e AlexPosn, AsTypeError e AlexPosn, MonadError e m) => Bool -> ByteString -> m Text

-- | An internal error occurred during type checking.
data InternalTypeError a
OpenTypeOfBuiltin :: (Type TyName ()) -> (Builtin ()) -> InternalTypeError a
data TypeError a
KindMismatch :: a -> (Type TyNameWithKind ()) -> (Kind ()) -> (Kind ()) -> TypeError a
TypeMismatch :: a -> (Term TyNameWithKind NameWithType ()) -> (Type TyNameWithKind ()) -> (NormalizedType TyNameWithKind ()) -> TypeError a
UnknownDynamicBuiltinName :: a -> UnknownDynamicBuiltinNameError -> TypeError a
InternalTypeErrorE :: a -> (InternalTypeError a) -> TypeError a
OutOfGas :: TypeError a
class AsTypeError r_a1iTb a_a1iAz | r_a1iTb -> a_a1iAz
_TypeError :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb (TypeError a_a1iAz)
_KindMismatch :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb (a_a1iAz, Type TyNameWithKind (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb (a_a1iAz, Term TyNameWithKind NameWithType (), Type TyNameWithKind (), NormalizedType TyNameWithKind ())
_UnknownDynamicBuiltinName :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb (a_a1iAz, UnknownDynamicBuiltinNameError)
_InternalTypeErrorE :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb (a_a1iAz, InternalTypeError a_a1iAz)
_OutOfGas :: AsTypeError r_a1iTb a_a1iAz => Prism' r_a1iTb ()

-- | Configuration of the type checker.
data TypeConfig
TypeConfig :: Bool -> DynamicBuiltinNameTypes -> Maybe Gas -> TypeConfig

-- | Whether to normalize type annotations.
[_typeConfigNormalize] :: TypeConfig -> Bool
[_typeConfigDynBuiltinNameTypes] :: TypeConfig -> DynamicBuiltinNameTypes

-- | The upper limit on the length of type reductions. If set to
--   <a>Nothing</a>, type reductions will be unbounded.
[_typeConfigGas] :: TypeConfig -> Maybe Gas

-- | Mapping from <a>DynamicBuiltinName</a>s to their <a>Type</a>s.
newtype DynamicBuiltinNameTypes
DynamicBuiltinNameTypes :: Map DynamicBuiltinName (Quote (Type TyName ())) -> DynamicBuiltinNameTypes
[unDynamicBuiltinNameTypes] :: DynamicBuiltinNameTypes -> Map DynamicBuiltinName (Quote (Type TyName ()))

-- | The type checking monad contains the <tt>BuiltinTable</tt> and it lets
--   us throw <a>TypeError</a>s.
type TypeCheckM ann = ReaderT TypeConfig (ExceptT (TypeError ann) Quote)

-- | Parse a program and typecheck it.
parseTypecheck :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, AsNormalizationError e TyName Name AlexPosn, AsRenameError e AlexPosn, AsTypeError e AlexPosn, MonadError e m, MonadQuote m) => TypeConfig -> ByteString -> m (NormalizedType TyNameWithKind ())

-- | Run the type checker with a default context.
runTypeCheckM :: TypeConfig -> TypeCheckM a b -> ExceptT (TypeError a) Quote b

-- | Typecheck a program.
typecheckPipeline :: (AsNormalizationError e TyName Name a, AsRenameError e a, AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Program TyName Name a -> m (NormalizedType TyNameWithKind ())

-- | The default amount of gas to run the typechecker with.
defaultTypecheckerGas :: Maybe Gas
defaultTypecheckerCfg :: TypeConfig
data Error a
ParseErrorE :: (ParseError a) -> Error a
UniqueCoherencyErrorE :: (UniqueError a) -> Error a
RenameErrorE :: (RenameError a) -> Error a
TypeErrorE :: (TypeError a) -> Error a
NormalizationErrorE :: (NormalizationError TyName Name a) -> Error a
class AsError r_a1jbz a_a1iTS | r_a1jbz -> a_a1iTS
_Error :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (Error a_a1iTS)
_ParseErrorE :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (ParseError a_a1iTS)
_UniqueCoherencyErrorE :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (UniqueError a_a1iTS)
_RenameErrorE :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (RenameError a_a1iTS)
_TypeErrorE :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (TypeError a_a1iTS)
_NormalizationErrorE :: AsError r_a1jbz a_a1iTS => Prism' r_a1jbz (NormalizationError TyName Name a_a1iTS)

-- | This error is returned whenever scope resolution of a
--   <a>DynamicBuiltinName</a> fails.
newtype UnknownDynamicBuiltinNameError
UnknownDynamicBuiltinNameErrorE :: DynamicBuiltinName -> UnknownDynamicBuiltinNameError
data UniqueError a
MultiplyDefined :: Unique -> a -> a -> UniqueError a
IncoherentUsage :: Unique -> a -> a -> UniqueError a
FreeVariable :: Unique -> a -> UniqueError a
data TermF tyname name a x
VarF :: a -> (name a) -> TermF tyname name a x
TyAbsF :: a -> (tyname a) -> (Kind a) -> x -> TermF tyname name a x
LamAbsF :: a -> (name a) -> (Type tyname a) -> x -> TermF tyname name a x
ApplyF :: a -> x -> x -> TermF tyname name a x
ConstantF :: a -> (Constant a) -> TermF tyname name a x
BuiltinF :: a -> (Builtin a) -> TermF tyname name a x
TyInstF :: a -> x -> (Type tyname a) -> TermF tyname name a x
UnwrapF :: a -> x -> TermF tyname name a x
IWrapF :: a -> (Type tyname a) -> (Type tyname a) -> x -> TermF tyname name a x
ErrorF :: a -> (Type tyname a) -> TermF tyname name a x
data TypeF tyname a x
TyVarF :: a -> (tyname a) -> TypeF tyname a x
TyFunF :: a -> x -> x -> TypeF tyname a x
TyIFixF :: a -> x -> x -> TypeF tyname a x
TyForallF :: a -> (tyname a) -> (Kind a) -> x -> TypeF tyname a x
TyBuiltinF :: a -> TypeBuiltin -> TypeF tyname a x
TyIntF :: a -> Natural -> TypeF tyname a x
TyLamF :: a -> (tyname a) -> (Kind a) -> x -> TypeF tyname a x
TyAppF :: a -> x -> x -> TypeF tyname a x

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: (Monad m) => QuoteT m a -> m a

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m
liftQuote :: MonadQuote m => Quote a -> m a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: Monad m => a -> Text -> QuoteT m (Name a)

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: Monad m => a -> Text -> QuoteT m (TyName a)

-- | A quasiquoter for creating Plutus Core types.
plcType :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core terms.
plcTerm :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core programs.
plcProgram :: QuasiQuoter

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())

-- | Take one PLC program and apply it to another.
applyProgram :: Program tyname name () -> Program tyname name () -> Program tyname name ()

module PlcTestUtils

-- | Class for ad-hoc overloading of things which can be turned into a PLC
--   program. Any errors from the process should be caught.
class GetProgram a
getProgram :: GetProgram a => a -> ExceptT SomeException IO (Program TyName Name ())
catchAll :: a -> ExceptT SomeException IO a
rethrow :: ExceptT SomeException IO a -> IO a
trivialProgram :: Term TyName Name () -> Program TyName Name ()
runPlc :: GetProgram a => [a] -> ExceptT SomeException IO EvaluationResult
goldenPlc :: GetProgram a => String -> a -> TestNested
goldenPlcCatch :: GetProgram a => String -> a -> TestNested
goldenEval :: GetProgram a => String -> [a] -> TestNested
goldenEvalCatch :: GetProgram a => String -> [a] -> TestNested
instance PlcTestUtils.GetProgram a => PlcTestUtils.GetProgram (Control.Monad.Trans.Except.ExceptT GHC.Exception.SomeException GHC.Types.IO a)
instance PlcTestUtils.GetProgram (Language.PlutusCore.Type.Program Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ())


-- | Reexports from modules from the
--   <tt>Language.PlutusCore.Generators.Internal</tt> folder.
module Language.PlutusCore.Generators

-- | <pre>
--   hoist lift
--   </pre>
liftT :: (MFunctor t, MonadTrans s, Monad m) => t m a -> t (s m) a

-- | Supply an environment to an inner <a>ReaderT</a>.
hoistSupply :: (MFunctor t, Monad m) => r -> t (ReaderT r m) a -> t m a

-- | Same as <a>choice</a>, but with a default generator to be used when
--   the supplied list of generators is empty.
choiceDef :: Monad m => GenT m a -> [GenT m a] -> GenT m a

-- | Generate a value, but do not show it in case an error occurs.
forAllNoShow :: Monad m => Gen a -> PropertyT m a

-- | Generate a value, but do not show it in case an error occurs. A
--   supplied generator has access to the <a>Monad</a> the whole property
--   has access to.
forAllNoShowT :: Monad m => GenT m a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation.
forAllPretty :: (Monad m, Pretty a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyT :: (Monad m, Pretty a) => GenT m a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation.
forAllPrettyPlc :: (Monad m, PrettyPlc a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyPlcT :: (Monad m, PrettyPlc a) => GenT m a -> PropertyT m a

-- | Generate a value wrapped in <a>Maybe</a> using the <a>PrettyPlc</a>
--   constraint for getting its <a>String</a> representation.
forAllPrettyPlcMaybe :: (Monad m, PrettyPlc a) => Gen (Maybe a) -> PropertyT m (Maybe a)

-- | Generate a value wrapped in <a>Maybe</a> using the <a>PrettyPlc</a>
--   constraint for getting its <a>String</a> representation. A supplied
--   generator has access to the <a>Monad</a> the whole property has access
--   to.
forAllPrettyPlcMaybeT :: (Monad m, PrettyPlc a) => GenT m (Maybe a) -> PropertyT m (Maybe a)

-- | Run a generator until it succeeds with a <a>Just</a>.
runQuoteSampleSucceed :: GenT Quote (Maybe a) -> IO a

-- | Throw a PLC error.
errorPlc :: PrettyPlc err => err -> b

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError
TypeEvalCheckErrorIllFormed :: (Error ()) -> TypeEvalCheckError

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: (Value TyName Name ()) -> (Value TyName Name ()) -> TypeEvalCheckError

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult
TypeEvalCheckResult :: NormalizedType TyNameWithKind () -> EvaluationResult -> TypeEvalCheckResult

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult -> NormalizedType TyNameWithKind ()

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult -> EvaluationResult

-- | The monad type-eval checking runs in.
type TypeEvalCheckM = ExceptT TypeEvalCheckError Quote

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (Term TyName Name () -> EvaluationResult) -> TermOf (TypedBuiltinValue Size a) -> TypeEvalCheckM (TermOf TypeEvalCheckResult)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: forall a. TermOf (TypedBuiltinValue Size a) -> Quote (Maybe (TermOf (Value TyName Name ())))

-- | A PLC <a>Term</a> along with the correspoding Haskell value.
data TermOf a
TermOf :: Term TyName Name () -> a -> TermOf a

-- | The PLC term
[_termOfTerm] :: TermOf a -> Term TyName Name ()

-- | The Haskell value.
[_termOfValue] :: TermOf a -> a

-- | A function of this type generates values of built-in typed (see
--   <a>TypedBuiltin</a> for the list of such types) and returns it along
--   with the corresponding PLC value. Bounds induced (as per the spec) by
--   the <a>Size</a> values must be met, but can be narrowed.
type TypedBuiltinGenT m = forall a. TypedBuiltin Size a -> GenT m (TermOf a)

-- | <a>TypedBuiltinGenT</a> specified to <a>Identity</a>.
type TypedBuiltinGen = TypedBuiltinGenT Identity

-- | Generate a UTF-8 lazy <tt>ByteString</tt> containg lower-case letters.
genLowerBytes :: Monad m => Range Int -> GenT m ByteString

-- | Update a typed built-ins generator by overwriting the
--   <tt>integer</tt>s generator.
updateTypedBuiltinGenInt :: MonadQuote m => (Integer -> Integer -> GenT m Integer) -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the
--   <tt>bytestring</tt>s generator.
updateTypedBuiltinGenBS :: MonadQuote m => (Int -> GenT m ByteString) -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the <tt>size</tt>s
--   generator.
updateTypedBuiltinGenSize :: MonadQuote m => TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the
--   <tt>boolean</tt>s generator.
updateTypedBuiltinGenBool :: MonadQuote m => GenT m Bool -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | A built-ins generator that always fails.
genTypedBuiltinFail :: Monad m => TypedBuiltinGenT m

-- | A default sized built-ins generator that produces values in bounds
--   seen in the spec.
genTypedBuiltinDef :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces values outside of bounds
--   seen in the spec for <tt>integer</tt>s and <tt>bytestring</tt>s.
genTypedBuiltinOutOfBounds :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces small values in bounds seen
--   in the spec.
genTypedBuiltinSmall :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in bounds
--   narrowed by a factor of 2, so that one can use '(+)' or '(-)' over
--   such integers without the risk of getting an overflow.
genTypedBuiltinSum :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in bounds
--   narrowed by <tt>isqrtt</tt>, so that one can use '(*)' over such
--   integers without the risk of getting an overflow.
genTypedBuiltinMultiply :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that doesn't produce <tt>0 ::
--   Integer</tt>, so that one case use <a>div</a> or <a>mod</a> over such
--   integers without the risk of dividing by zero.
genTypedBuiltinDivide :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in the
--   <tt>(high <a>div</a> 2, high]</tt> interval, so that one can use '(+)'
--   over such integers and reliably get an overflow.
genTypedBuiltinAddFailure :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in the
--   <tt>(isqrt high, high]</tt> interval, so that one can use '(*)' over
--   such integers and reliably get an overflow.
genTypedBuiltinMultiplyFailure :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <tt>ByteString</tt>s of such
--   lengths that one can use <a>&lt;&gt;</a> over them without the risk of
--   getting an overflow.
genTypedBuiltinConcatenate :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <tt>ByteString</tt>s of such
--   lengths that one can use <a>&lt;&gt;</a> over them and reliably gen an
--   overflow.
genTypedBuiltinConcatenateFailure :: MonadQuote m => TypedBuiltinGenT m

-- | The type used in generators defined in this module. It's parameterized
--   by a <a>BuiltinGensT</a> which makes it possible to supply different
--   generators of built-in types. For example, <tt>genTypedBuiltinDiv</tt>
--   never generates a zero, so this generator can be used in order to
--   avoid the divide-by-zero exception. Supplied generators are of
--   arbitrary complexity and can call the currently running generator
--   recursively, for example.
type PlcGenT m = GenT (ReaderT (BuiltinGensT m) m)

-- | One iterated application of a <tt>head</tt> to <tt>arg</tt>s
--   represented in three distinct ways.
data IterAppValue head arg r
IterAppValue :: Term TyName Name () -> IterApp head arg -> TypedBuiltinValue Size r -> IterAppValue head arg r

-- | As a PLC <a>Term</a>.
[_iterTerm] :: IterAppValue head arg r -> Term TyName Name ()

-- | As an <a>IterApp</a>.
[_iterApp] :: IterAppValue head arg r -> IterApp head arg

-- | As a Haskell value.
[_iterTbv] :: IterAppValue head arg r -> TypedBuiltinValue Size r

-- | Run a <a>PlcGenT</a> computation by supplying built-ins generators.
runPlcT :: Monad m => GenT m Size -> TypedBuiltinGenT m -> PlcGenT m a -> GenT m a

-- | Generate a size from bounds.
genSizeIn :: Monad m => Size -> Size -> GenT m Size

-- | Generate a size using the default range of <tt>[2..4]</tt>.
genSizeDef :: Monad m => GenT m Size

-- | Either return a size taken from a <a>TypedBuiltinSized</a> or generate
--   one using <a>genSizeDef</a>.
genSizeFrom :: Monad m => TypedBuiltin Size a -> GenT m Size

-- | Generate a <a>BuiltinSized</a>.
genBuiltinSized :: Monad m => GenT m BuiltinSized

-- | Generate a <a>Builtin</a>.
genBuiltin :: Monad m => GenT m Size -> GenT m (BuiltinType size)

-- | Generate a <a>Builtin</a> and supply its typed version to a
--   continuation.
withTypedBuiltinGen :: Monad m => GenT m Size -> (forall a. TypedBuiltin size a -> GenT m c) -> GenT m c

-- | Generate a <a>Term</a> along with the value it computes to, having a
--   generator of terms of built-in types.
withCheckedTermGen :: TypedBuiltinGenT Quote -> (forall a. TypedBuiltin Size a -> Maybe (TermOf (Value TyName Name ())) -> GenT Quote c) -> GenT Quote c

-- | Generate an <a>IterAppValue</a> from a <a>Denotation</a>. If the
--   <a>Denotation</a> has a functional type, then all arguments are
--   generated and supplied to the denotation, the resulting value is
--   forced and if there are any exceptions, then all generated arguments
--   are discarded and another attempt is performed (this process does not
--   loop). Since <a>IterAppValue</a> consists of three components, we 1.
--   grow the <a>Term</a> component by applying it to arguments using
--   <a>Apply</a> 2. grow the <a>IterApp</a> component by appending
--   arguments to its spine 3. feed arguments to the Haskell function
genIterAppValue :: forall head r m. Monad m => Denotation head Size r -> PlcGenT m (IterAppValue head (Term TyName Name ()) r)

-- | Generate a PLC <a>Term</a> of the specified type and the corresponding
--   Haskell value. Generates first-order functions and constants including
--   constant applications. Arguments to functions and <a>BuiltinName</a>s
--   are generated recursively.
genTerm :: TypedBuiltinGenT Quote -> DenotationContext -> Int -> TypedBuiltinGenT Quote

-- | Generates a <a>Term</a> with rather small values to make out-of-bounds
--   failures less likely. There are still like a half of terms that fail
--   with out-of-bounds errors being evaluated.
genTermLoose :: TypedBuiltinGenT Quote

-- | Generate a <a>TypedBuiltin</a> and a <a>TermOf</a> of the
--   corresponding type, attach the <a>TypedBuiltin</a> to the value part
--   of the <a>TermOf</a> and pass that to a continuation.
withAnyTermLoose :: (forall a. TermOf (TypedBuiltinValue Size a) -> GenT Quote c) -> GenT Quote c

-- | Haskell denotation of a PLC object. An object can be a
--   <a>BuiltinName</a> or a variable for example.
data Denotation object size r
Denotation :: object -> object -> Term TyName Name () -> a -> TypeScheme size a r -> Denotation object size r

-- | A PLC object.
[_denotationObject] :: Denotation object size r -> object

-- | How to embed the object into a term.
[_denotationToTerm] :: Denotation object size r -> object -> Term TyName Name ()

-- | The denotation of the object. E.g. the denotation of <a>AddInteger</a>
--   is '(+)'.
[_denotationItself] :: Denotation object size r -> a

-- | The <a>TypeScheme</a> of the object. See <tt>sizeIntIntInt</tt> for
--   example.
[_denotationScheme] :: Denotation object size r -> TypeScheme size a r

-- | A member of a <a>DenotationContext</a>. <tt>object</tt> is
--   existentially quantified, so the only thing that can be done with it,
--   is turning it into a <a>Term</a> using <a>_denotationToTerm</a>.
data DenotationContextMember r
DenotationContextMember :: (Denotation object Size r) -> DenotationContextMember r

-- | A context of <a>DenotationContextMember</a>s. Each row is a mapping
--   from a type to a list of things that can return that type. For example
--   it can contain a mapping from <tt>integer</tt> to 1. a bound variable
--   of type <tt>integer</tt> 2. a bound variable of functional type with
--   the result being <tt>integer</tt> 3. the <a>AddInteger</a>
--   <a>BuiltinName</a> or any other <a>BuiltinName</a> which returns an
--   <tt>integer</tt>.
newtype DenotationContext
DenotationContext :: DMap (TypedBuiltin ()) (Compose [] DenotationContextMember) -> DenotationContext
[unDenotationContext] :: DenotationContext -> DMap (TypedBuiltin ()) (Compose [] DenotationContextMember)

-- | Get the <a>Denotation</a> of a variable.
denoteVariable :: Name () -> TypedBuiltin size r -> r -> Denotation (Name ()) size r

-- | Get the <a>Denotation</a> of a <a>TypedBuiltinName</a>.
denoteTypedBuiltinName :: TypedBuiltinName a r -> a -> Denotation BuiltinName size r

-- | Insert a variable into a <a>DenotationContext</a>.
insertVariable :: Name () -> TypedBuiltin Size a -> a -> DenotationContext -> DenotationContext

-- | Insert a <a>TypedBuiltinName</a> into a <a>DenotationContext</a>.
insertTypedBuiltinName :: TypedBuiltinName a r -> a -> DenotationContext -> DenotationContext

-- | A <a>DenotationContext</a> that consists of <a>TypedBuiltinName</a>s.
typedBuiltinNames :: DenotationContext


-- | Sample generators used for tests.
module Language.PlutusCore.Generators.Interesting

-- | The type of terms-and-their-values generators.
type TermGen size a = GenT Quote (TermOf (TypedBuiltinValue size a))

-- | Generates application of a built-in that returns a <tt>boolean</tt>,
--   immediately saturated afterwards.
--   
--   <pre>
--   lessThanInteger {integer s1} $i1 $i2 {integer s2} $j1 $j2 == if i1 &lt; i2 then j1 else j2
--   </pre>
genOverapplication :: TermGen size Integer

-- | <tt>i -&gt; product [1 :: Integer .. i]</tt> as a PLC term.
--   
--   <pre>
--   /\(s :: size) -&gt; \(i : integer s) -&gt;
--   </pre>
--   
--   let ss = sizeOfInteger {s} i in product {s} ss (enumFromTo {s}
--   (resizeInteger {1} {s} ss 1!1) i)
getBuiltinFactorial :: Quote (Term TyName Name ())

-- | Apply some factorial function to its <a>Size</a> and <a>Integer</a>
--   arguments. This function exist, because we have another implementation
--   via dynamic built-ins and want to compare it to the direct
--   implementation from the above.
applyFactorial :: Term TyName Name () -> Size -> Integer -> Term TyName Name ()

-- | Generate a term that computes the factorial of an <tt>integer</tt> and
--   return it along with the factorial of the corresponding <a>Integer</a>
--   computed on the Haskell side.
genFactorial :: TermGen size Integer

-- | Generate a term that computes the ith Fibonacci number and return it
--   along with the corresponding <a>Integer</a> computed on the Haskell
--   side.
genNaiveFib :: TermGen size Integer

-- | Generate an <a>Integer</a>, turn it into a Scott-encoded PLC
--   <tt>Nat</tt> (see <a>getBuiltinNat</a>), turn that <tt>Nat</tt> into
--   the corresponding PLC <tt>integer</tt> using a fold (see
--   <a>getBuiltinFoldNat</a>) defined in terms of generic fix (see
--   <a>getBuiltinFix</a>) and return the result along with the original
--   <a>Integer</a>
genNatRoundtrip :: GenT Quote (TermOf (TypedBuiltinValue size Integer))

-- | Generate a list of <a>Integer</a>s, turn it into a Scott-encoded PLC
--   <tt>List</tt> (see <a>getBuiltinList</a>), sum elements of the list
--   (see <a>getBuiltinSum</a>) and return it along with the sum of the
--   original list.
genListSum :: TermGen size Integer

-- | Generate a <tt>boolean</tt> and two <tt>integer</tt>s and check
--   whether <tt>if b then i1 else i2</tt> means the same thing in Haskell
--   and PLC. Terms are generated using <a>genTermLoose</a>.
genIfIntegers :: TermGen size Integer

-- | Apply a function to all interesting generators and collect the
--   results.
fromInterestingTermGens :: (forall a. String -> TermGen size a -> c) -> [c]


-- | This module defines functions useful for testing.
module Language.PlutusCore.Generators.Test

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError
TypeEvalCheckErrorIllFormed :: (Error ()) -> TypeEvalCheckError

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: (Value TyName Name ()) -> (Value TyName Name ()) -> TypeEvalCheckError

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult
TypeEvalCheckResult :: NormalizedType TyNameWithKind () -> EvaluationResult -> TypeEvalCheckResult

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult -> NormalizedType TyNameWithKind ()

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult -> EvaluationResult

-- | The monad type-eval checking runs in.
type TypeEvalCheckM = ExceptT TypeEvalCheckError Quote

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (Term TyName Name () -> EvaluationResult) -> TermOf (TypedBuiltinValue Size a) -> TypeEvalCheckM (TermOf TypeEvalCheckResult)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: forall a. TermOf (TypedBuiltinValue Size a) -> Quote (Maybe (TermOf (Value TyName Name ())))

-- | Generate a term using a given generator and check that it's well-typed
--   and evaluates correctly.
sampleTermValue :: TermGen Size a -> IO (TermOf (Value TyName Name ()))

-- | Generate a pair of files: <tt><a>folder</a>.<a>name</a>.plc</tt> and
--   <tt><a>folder</a>.<a>name</a>.plc.golden</tt>. The first file contains
--   a term generated by a term generator (wrapped in <a>Program</a>), the
--   second file contains the result of evaluation of the term.
sampleProgramValueGolden :: String -> String -> TermGen Size a -> IO ()

-- | A property-based testing procedure for evaluators. Checks whether a
--   term generated along with the value it's supposed to compute to indeed
--   computes to that value according to the provided evaluate.
propEvaluate :: (Term TyName Name () -> EvaluationResult) -> GenT Quote (TermOf (TypedBuiltinValue Size a)) -> Property


-- | This module exports all available examples via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire set of examples in a convenient way: each time a
--   function / data type is added to examples, none of the tests is
--   required to be adapted, instead you just add the new definition to
--   <a>examples</a> defined below and all the tests see it automatically.
module Language.PlutusCore.Examples.Everything

-- | All examples exported as a single value.
examples :: PlcFolderContents
